<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<id>https://www.devlead.se/</id>
	<title>@devlead - Mattias Karlsson's Blog</title>
	<link rel="self" href="https://www.devlead.se/" />
	<rights>© Mattias Karlsson 2024</rights>
	<updated>2024-09-22T19:39:11Z</updated>
	<logo>https://cdn.devlead.se/clipimg-vscode/2021/01/11/1f2af322-a19f-753d-bd3e-00118dc674f1.png?sv=2019-12-12&amp;st=2021-01-10T15%253A16%253A48Z&amp;se=2031-01-11T15%253A16%253A48Z&amp;sr=b&amp;sp=r&amp;sig=RYHdZjTvO%252Fw0tUGsgnIiGJRhTiQQPHnEsSKtnV14Yoc%253D</logo>
	<entry>
		<id>https://www.devlead.se/posts/2024/2024-09-22-preparing-for-dotnet-9</id>
		<title>Preparing for .NET 9</title>
		<author>
			<name>devlead</name>
		</author>
		<link href="https://www.devlead.se/posts/2024/2024-09-22-preparing-for-dotnet-9" />
		<link rel="enclosure" type="image" href="https://cdn.devlead.se/clipimg-vscode/2024/09/22/df979602c75a4074bff02d5d02fdb88e.jpg?sv=2023-01-03&amp;st=2024-09-22T12%253A57%253A23Z&amp;se=2035-07-29T12%253A57%253A00Z&amp;sr=b&amp;sp=r&amp;sig=V0HqKU5KQUe8JuTyKzmuxyNNyyX735PAm4M6Lx%252FaXoY%253D" />
		<updated>2024-09-22T00:00:00Z</updated>
		<content>&lt;p&gt;.NET 9 is just around the corner with the General Availability (GA) release scheduled for November 2024. The .NET 9 RC 1 (released September 10, 2024) already comes with a Go-Live license, meaning it’s supported by Microsoft for use in production environments.&lt;/p&gt;
&lt;p&gt;If you’re currently running .NET 6 or newer, I’ve found the migration process to .NET 9 to be fairly straightforward. Here are some key steps to guide you through the transition.&lt;/p&gt;
&lt;h3 id="update-dependencies"&gt;1. Update Dependencies&lt;/h3&gt;
&lt;p&gt;Update outdated dependencies. This is always a good practice before migrating, many incompatibility issues are often sorted this way. An excellent tool aiding with this is the &lt;a href="https://github.com/dotnet-outdated/dotnet-outdated"&gt;dotnet-outdated&lt;/a&gt; tool, run &lt;code&gt;dotnet outdated &amp;lt;solution/project folder&amp;gt;&lt;/code&gt; to check for any out of date packages and it can even update the packages for you.&lt;/p&gt;
&lt;h3 id="remove-obsolete-target-frameworks"&gt;2. Remove Obsolete Target Frameworks&lt;/h3&gt;
&lt;p&gt;If you are still targeting obsolete frameworks like &lt;code&gt;net7.0&lt;/code&gt;, it's time to clean them up. Many newer .NET 9 assemblies only target .NET 8 and above. If you need to maintain compatibility with .NET 6, you can use conditionals on your package references as a workaround during the interim, example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;    &amp;lt;PackageReference Condition=&amp;quot; '$(TargetFramework)' == 'net6.0' &amp;quot; Include=&amp;quot;Verify.Http&amp;quot; Version=&amp;quot;5.0.1&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Condition=&amp;quot; '$(TargetFramework)' != 'net6.0' &amp;quot; Include=&amp;quot;Verify.Http&amp;quot; Version=&amp;quot;6.3.0&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="update-global.json"&gt;3. Update &lt;code&gt;global.json&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;An easy way to update your &lt;code&gt;global.json&lt;/code&gt; is to simply delete it and run &lt;code&gt;dotnet new globaljson&lt;/code&gt;. This command will create a &lt;code&gt;global.json&lt;/code&gt; matching the preview SDK, which will work smoothly in your CI/CD pipeline.&lt;/p&gt;
&lt;h3 id="add-net9.0-target-framework-moniker-tfm"&gt;4. Add &lt;code&gt;net9.0&lt;/code&gt; Target Framework Moniker (TFM)&lt;/h3&gt;
&lt;p&gt;Add the &lt;code&gt;net9.0&lt;/code&gt; target framework to your project, using the &lt;code&gt;TargetFrameworks&lt;/code&gt; MSBuild property (if you're using &lt;code&gt;TargetFramework&lt;/code&gt; today and want to multitarget it will need to be relaced with &lt;code&gt;TargetFrameworks&lt;/code&gt;), example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;TargetFrameworks&amp;gt;net9.0;net8.0&amp;lt;/TargetFrameworks&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After November 12, 2024, the supported frameworks will be:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.NET 8 (Long Term Support until November 10, 2026)&lt;/li&gt;
&lt;li&gt;.NET 9 (Standard Term Support, 18 months from release)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="build-and-address-issues"&gt;5. Build and Address Issues&lt;/h3&gt;
&lt;p&gt;Once you’ve set everything up, build your solution and resolve any issues that arise:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Source Issues&lt;/strong&gt;: The only code issue I encountered was an &lt;code&gt;Index&lt;/code&gt; extension method for &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;, which is now built-in with .NET 9. In my case, the method was internal and semantically different, so I simply renamed it.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Dependency Errors/Warnings&lt;/strong&gt;: The .NET 9 SDK is more vocal about packages with security issues or deprecated dependencies. Even transient dependencies (ones you don’t directly reference) might trigger warnings. &lt;code&gt;dotnet nuget why&lt;/code&gt; is helpful here. You can either pin specific versions or migrate to replacement packages (especially common with Azure SDKs).&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="my-experience-running.net-9-in-production"&gt;My Experience Running .NET 9 in Production&lt;/h3&gt;
&lt;p&gt;I’ve had code running on .NET 9 in production since the day after RC1. It’s not about being an early adopter for the sake of it, but about preparing for the future. By picking small, isolated workloads, I’m learning what challenges might come up during a larger migration. There are many things we can prepare for now so that the full migration is as smooth as possible.&lt;/p&gt;
&lt;p&gt;In fact, you can start using the new .NET 9 SDK today while still targeting older frameworks, and gaining access to new build-time features while staying on your current runtime.&lt;/p&gt;
&lt;p&gt;Overall, my experience running .NET 9 in production has been smooth sailing, with only minor issues. The one hiccup I encountered involved the .NET 9 base Docker images, which use a slightly newer Linux distribution, requiring some native binaries to be installed. But that’s exactly the kind of valuable lesson you want to learn early before migrating all your workloads. One common example is &lt;a href="https://www.nuget.org/packages/System.Text.Json"&gt;System.Text.Json&lt;/a&gt; which many packages reference old and outdated versions of, by explicitly adding a package reference to it, you're pinning the version used by your project, example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;PackageReference Include=&amp;quot;System.Text.Json&amp;quot; Version=&amp;quot;8.0.4&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="adding-net9.0-to-my-open-source-tools"&gt;Adding &lt;code&gt;net9.0&lt;/code&gt; to My Open-Source Tools&lt;/h3&gt;
&lt;p&gt;I’ve already started adding the &lt;code&gt;net9.0&lt;/code&gt; target framework to my OSS tools. Here are a few that have been shipped and published so far:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.nuget.org/packages/ARI"&gt;&lt;strong&gt;ARI&lt;/strong&gt; - Azure Resource Inventory&lt;/a&gt; .NET Tool: Inventories and documents Azure Tenant resources.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.nuget.org/packages/Blobify"&gt;&lt;strong&gt;Blobify&lt;/strong&gt; - Blobify&lt;/a&gt; .NET Tool: Archives local files to Azure Blob Storage.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/yourlink"&gt;&lt;strong&gt;BRI&lt;/strong&gt; - Bicep Registry Inventory&lt;/a&gt; .NET Tool: Inventories and documents Bicep modules in an Azure container registry.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.nuget.org/packages/DPI"&gt;&lt;strong&gt;DPI&lt;/strong&gt; - Dependency Inventory&lt;/a&gt; .NET Tool: Inventories dependencies to Azure Log Analytics.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.nuget.org/packages/UnpackDacPac"&gt;&lt;strong&gt;UnpackDacPac&lt;/strong&gt; - Unpack DAC Package&lt;/a&gt; .NET Tool: Extracts a DACPAC and generates a deployment script to a target folder, without needing a live database.&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>Initial reflections after running .NET 9 in production</summary>
	</entry>
	<entry>
		<id>https://www.devlead.se/posts/2024/2024-09-05-introducing-blobify</id>
		<title>Introducing Blobify</title>
		<author>
			<name>devlead</name>
		</author>
		<link href="https://www.devlead.se/posts/2024/2024-09-05-introducing-blobify" />
		<link rel="enclosure" type="image" href="https://cdn.devlead.se/clipimg-vscode/2024/09/05/fe73bb0124cc43a1af9520490a6367a8.jpg?sp=r&amp;st=2024-09-04T18:14:45Z&amp;se=2035-05-01T02:14:45Z&amp;spr=https&amp;sv=2022-11-02&amp;sr=b&amp;sig=HuC7WPifcu40wqwTXUZJ77qxzzfs%252BKtSKrkbJrmbqJw%253D" />
		<updated>2024-09-05T00:00:00Z</updated>
		<content>&lt;p&gt;I recently needed a seamless and efficient way to recursively archive and move local files to Azure Blob Storage with relative folder structure intact. That’s why I wrote Blobify, a .NET global tool that simplifies the process of transferring files from a local directory to an Azure Blob Storage container.&lt;/p&gt;
&lt;h2 id="easy-installation-with.net-sdk-cli"&gt;Easy Installation with .NET SDK CLI&lt;/h2&gt;
&lt;p&gt;Blobify is installed using the .NET SDK CLI. Ensure you have the .NET 8 SDK installed, and type the following command:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet tool install -g Blobify
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="simple-and-powerful-command-line-options"&gt;Simple and Powerful Command Line Options&lt;/h2&gt;
&lt;p&gt;Utilizing Blobify is straightforward with its archive command and options.&lt;/p&gt;
&lt;h3 id="usage"&gt;Usage&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;blobify archive &amp;lt;inputpath&amp;gt; &amp;lt;azureStorageAccount&amp;gt; &amp;lt;azureStorageAccountContainer&amp;gt; [OPTIONS]
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="example"&gt;Example&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;blobify archive c:\local\folder targetaccount targetcontainer
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id="arguments"&gt;Arguments&lt;/h5&gt;
&lt;pre&gt;&lt;code class="language-text"&gt;    &amp;lt;inputpath&amp;gt;                       Input path
    &amp;lt;azureStorageAccount&amp;gt;             Azure Storage Account Name
    &amp;lt;azureStorageAccountContainer&amp;gt;    Azure Storage Account Container Name
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id="options"&gt;Options&lt;/h5&gt;
&lt;pre&gt;&lt;code class="language-text"&gt;    -h, --help               Prints help information
        --azure-tenant-id    Azure Tentant ID to sign into
        --file-pattern       Local file pattern to match (default **/*.*)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="secure-authentication-and-reliable-uploads"&gt;Secure Authentication and Reliable Uploads&lt;/h2&gt;
&lt;p&gt;Blobify ensures secure authentication using Azure EntraID and Azure.Identity's &lt;a href="https://learn.microsoft.com/en-us/dotnet/api/azure.identity.defaultazurecredential?view=azure-dotnet"&gt;DefaultAzureCredential&lt;/a&gt; . It uploads files from the specified source folder—and optionally a file pattern, and removes them locally only after verifying that a file with the same hash exists in the target blob storage container. If the file already exists on blob it won't upload it, but if hashes macthes it'll remove the local file.&lt;/p&gt;
&lt;div class="mermaid"&gt;flowchart TD
    ls[List files in source path]
    exists[Verifies if blob file already exists]
    upload[Upload file]
    verify[Verifies MD5 hash]
    delete[Delete file]
    skip[Skip file]
    ls --&gt; exists
    exists --Found--&gt; verify
    exists --Not Found--&gt; upload
    upload --&gt; verify
    verify --Matches--&gt; delete
    verify --Not Matches--&gt; skip
&lt;/div&gt;
&lt;h2 id="example-usage-in-an-azure-devops-pipeline-task"&gt;Example Usage in an Azure DevOps Pipeline task&lt;/h2&gt;
&lt;p&gt;My personal use case was to archive local files on a schedules, this was achived with a scheduled Azure DevOps Pipelines running on a local DevOps agent, example Azure Pipelines task:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;    - task: AzureCLI&amp;#64;2
      displayName: Archive files
      inputs:
        azureSubscription: 'azureSubscription'
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          dotnet tool restore
          dotnet blobify archive c:\local\agent\folder account container
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above task expects Blobify to be installed and pinned to a specific verion using a .NET tool manifest in repository, a manifest can be created using the .NET SDK CLI&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet new tool-manifest
dotnet tool install Blobify
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="open-source-and-free-to-use"&gt;Open Source and Free to Use&lt;/h2&gt;
&lt;p&gt;Blobify is available for free on NuGet and is open source, with its code accessible on GitHub. It is licensed under the permissive MIT license.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NuGet Package: &lt;a href="https://www.nuget.org/packages/Blobify/"&gt;Blobify on NuGet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;GitHub Repository: &lt;a href="https://github.com/devlead/Blobify"&gt;Blobify on GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>A .NET Global tool that archives (moves) files from a local folder to an Azure Blob Storage container.</summary>
	</entry>
	<entry>
		<id>https://www.devlead.se/posts/2024/2024-02-08-introducing-ari</id>
		<title>Introducing ARI</title>
		<author>
			<name>devlead</name>
		</author>
		<link href="https://www.devlead.se/posts/2024/2024-02-08-introducing-ari" />
		<link rel="enclosure" type="image" href="https://cdn.devlead.se/clipimg-vscode/2024/02/08/23be558ef4784e74a88b6bab00141708.jpg?sv=2021-10-04&amp;st=2024-02-08T19%253A03%253A22Z&amp;se=2050-12-16T19%253A05%253A00Z&amp;sr=b&amp;sp=r&amp;sig=MYOLIoM7zuZkWN7OQmLDVMTP796IKEhotMKRCtPYIsY%253D" />
		<updated>2024-02-08T00:00:00Z</updated>
		<content>&lt;p&gt;If you are working with Azure, you might have encountered the challenge of keeping track of all the subscriptions, resource groups, and resources that you have in your tenant. You might also want to document them in a clear and consistent way, for example, for compliance, auditing, or reporting purposes.&lt;/p&gt;
&lt;p&gt;That's why I created ARI, a .NET tool that inventories and documents your Azure tenant's subscriptions, resource groups, and resources. ARI stands for Azure Resource Inventory, and it is a free and open source tool that you can install and use with the .NET 7 or 8 SDK.&lt;/p&gt;
&lt;h2 id="how-to-install-ari"&gt;How to install ARI&lt;/h2&gt;
&lt;p&gt;ARI is available as a NuGet package at &lt;a href="https://www.nuget.org/packages/ARI"&gt;nuget.org/packages/ARI&lt;/a&gt;. You can install it either globally on your machine or locally in a specific folder or repository.&lt;/p&gt;
&lt;p&gt;To install it globally, run the following command:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet tool install --global ARI
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To install it locally, you need to create a tool manifest file first. You can do this by running the following command in the folder where you want to use ARI:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet new tool-manifest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then, you can install ARI in that folder by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet tool install --local ARI
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="how-to-use-ari"&gt;How to use ARI&lt;/h2&gt;
&lt;p&gt;Once you have installed ARI, you can use it by typing &lt;code&gt;ari&lt;/code&gt; if you installed it globally, or &lt;code&gt;dotnet ari&lt;/code&gt; if you installed it locally.&lt;/p&gt;
&lt;p&gt;You can use the &lt;code&gt;-h&lt;/code&gt; or &lt;code&gt;--help&lt;/code&gt; parameters to get the current list of available commands and options. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;ari --help
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;ari &amp;lt;command&amp;gt; --help
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The main current available command of ARI is &lt;code&gt;inventory&lt;/code&gt;, which takes a tenant ID and an output path as required parameters. It also has some optional parameters that you can use to customize the inventory process. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;ari inventory &amp;lt;tenantId&amp;gt; &amp;lt;outputpath&amp;gt; [options]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;inventory&lt;/code&gt; command will scan your Azure tenant and generate a set of GitHub flavoured markdown files that document your subscriptions, resource groups, and resources. It will also create indexes by tag name and value, or by resources missing tags.&lt;/p&gt;
&lt;h2 id="how-to-contribute-to-ari"&gt;How to contribute to ARI&lt;/h2&gt;
&lt;p&gt;ARI is licensed under the MIT license, which means you can use it for any purpose, modify it, and distribute it freely. The source code is hosted on GitHub at &lt;a href="https://github.com/devlead/ari"&gt;github.com/devlead/ari&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I welcome any feedback, suggestions, bug reports, or pull requests from the community. If you want to contribute to ARI, please check out the issues on GitHub.&lt;/p&gt;
&lt;h2 id="how-to-use-the-output-of-ari"&gt;How to use the output of ARI&lt;/h2&gt;
&lt;p&gt;The output of ARI is a set of GitHub flavored markdown files that you can use for various purposes. For example, you can use them with static site generators, wikis, or other tools that support markdown.&lt;/p&gt;
&lt;p&gt;One example of a static site generator that works well with ARI is Statiq ( &lt;a href="https://statiq.dev/"&gt;statiq.dev&lt;/a&gt; ), which is also a .NET framework for generating static websites and markdown files is one of its supported input formats. You can see an example of a static website generated using Statiq and ARI at &lt;a href="https://www.devlead.se/ARI/"&gt;devlead.se/ARI&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I hope you find ARI useful and helpful for your Azure projects. Please let me know what you think and how I can improve it.&lt;/p&gt;
&lt;p&gt;Thank you for reading!&lt;/p&gt;
</content>
		<summary>A DevOps tool to document a Azure tenant resources</summary>
	</entry>
	<entry>
		<id>https://www.devlead.se/posts/2023/2023-11-29-introducing-unpackdacpac</id>
		<title>Introducing UnpackDacPac</title>
		<author>
			<name>devlead</name>
		</author>
		<link href="https://www.devlead.se/posts/2023/2023-11-29-introducing-unpackdacpac" />
		<link rel="enclosure" type="image" href="https://cdn.devlead.se/clipimg-vscode/2023/11/29/d29f363677f845559d19401cd5a47318.jpg?sv=2021-10-04&amp;st=2023-11-29T17%253A14%253A21Z&amp;se=2035-11-30T17%253A14%253A00Z&amp;sr=b&amp;sp=r&amp;sig=ga7enWBL804T0haYj29QJE7hvaV14REXobavSOZ4wwU%253D" />
		<updated>2023-11-29T00:00:00Z</updated>
		<content>&lt;p&gt;If you work with SQL Server databases, you may have encountered DAC packages, or dacpacs, which are a way of packaging a database's schema and seed data for deployment or migration. Dacpacs are useful for deploying databases to different environments, such as development, testing, or production, but it's tooling comes with some limitations. For example, you cannot easily inspect the contents of a dacpac file without having a running instance of SQL Server.&lt;/p&gt;
&lt;p&gt;That's why I created UnpackDacPac, a .NET tool that enables you to extract a dacpac file and generate a deployment script to a target folder without the need to deploy it to an actual database. A really useful for example when you need to debug a failed deployment or retrieve an old version of a SQL object from just a DevOps build artifact.
UnpackDacPac is a cross-platform tool that runs on .NET SDK 6, 7, and 8 (&lt;em&gt;If you don't have the .NET SDK installed, you can get it from &lt;a href="https://get.dot.net/"&gt;here&lt;/a&gt;&lt;/em&gt;).&lt;/p&gt;
&lt;h2 id="installation"&gt;Installation&lt;/h2&gt;
&lt;p&gt;You can install UnpackDacPac as a global tool from the command line by typing:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet tool install --global UnpackDacPac
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;The usage of UnpackDacPac is simple:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;unpackdacpac unpack &amp;lt;dacPacPath&amp;gt; &amp;lt;outputPath&amp;gt; [OPTIONS]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For example, if you have a dacpac file named Source.dacpac and you want to extract it to a folder named TargetPath, you can run:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;unpackdacpac unpack Source.dacpac TargetPath
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will create the following files in the TargetPath folder:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DacMetadata.xml&lt;/code&gt;: This file contains the metadata of the dacpac, such as the name, version, description, and dependencies of the database.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Deploy.sql&lt;/code&gt;: This file contains the generated deployment script that can be used to create or update a database from the dacpac.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;model.sql&lt;/code&gt;: This file contains the formatted SQL code that defines the schema and data of the database.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;model.xml&lt;/code&gt;: This file contains the XML representation of the database model.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Origin.xml&lt;/code&gt;: This file contains the origin information of the dacpac, such as the source server and database name.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;postdeploy.sql&lt;/code&gt;: This file contains any post-deployment scripts that are included in the dacpac.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;One of the features of UnpackDacPac is that you can exclude certain types of objects from the generated deployment script by using the &lt;code&gt;--deploy-script-exclude-object-type&lt;/code&gt; parameter. For example, if you want to exclude users, logins, and role memberships from the deployment script, you can run:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;unpackdacpac unpack Source.dacpac TargetPath --deploy-script-exclude-object-type Users --deploy-script-exclude-object-type Logins --deploy-script-exclude-object-type RoleMembership
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will generate a deployment script that does not contain statements related to users, logins, or role memberships.&lt;/p&gt;
&lt;h2 id="where-to-find-unpackdacpac"&gt;Where to find UnpackDacPac?&lt;/h2&gt;
&lt;p&gt;UnpackDacPac is an open-source project under a permissive MIT license, the source can be found on &lt;a href="https://github.com/devlead/UnpackDacPac"&gt;GitHub&lt;/a&gt; and the NuGet package at &lt;a href="https://www.nuget.org/packages/UnpackDacPac"&gt;NuGet.org&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="feedback-and-suggestions"&gt;Feedback and suggestions&lt;/h2&gt;
&lt;p&gt;I hope you find UnpackDacPac useful and feel free to provide any feedback, suggestions, or pull requests.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Happy unpacking!&lt;/em&gt;&lt;/p&gt;
</content>
		<summary>A .NET Tool for Extracting DAC Packages</summary>
	</entry>
	<entry>
		<id>https://www.devlead.se/posts/2023/2023-11-27-introducing-bri</id>
		<title>Introducing BRI</title>
		<author>
			<name>devlead</name>
		</author>
		<link href="https://www.devlead.se/posts/2023/2023-11-27-introducing-bri" />
		<link rel="enclosure" type="image" href="https://cdn.devlead.se/clipimg-vscode/2022/11/27/9a2ae7d59ab04134b044699dfa437e61.jpg?sv=2021-10-04&amp;st=2023-11-27T19%253A40%253A55Z&amp;se=2031-11-28T19%253A40%253A00Z&amp;sr=b&amp;sp=r&amp;sig=0KWUea7yaM5YorSAtmNaMUCHPjJRaMiqif95E1o%252BW%252Bo%253D" />
		<updated>2023-11-27T00:00:00Z</updated>
		<content>&lt;p&gt;Are you looking for a way to document your Azure &lt;a href="https://learn.microsoft.com/en-us/azure/azure-resource-manager/bicep/overview?tabs=bicep"&gt;Bicep&lt;/a&gt; &lt;a href="https://learn.microsoft.com/en-us/azure/azure-resource-manager/bicep/modules"&gt;modules&lt;/a&gt; in a simple and elegant way? If so, you might want to check out BRI, a .NET tool that I created to help you with that.&lt;/p&gt;
&lt;h2 id="what-is-bri"&gt;What is BRI?&lt;/h2&gt;
&lt;p&gt;BRI stands for Bicep registry inventory, and it does exactly what the name suggests: it scans a provided Azure Container Registry for any published Bicep modules and generates markdown files for each module version. These markdown files contain information about the module's input parameters, output values, and example usage. You can then use these files with any static site generator that supports markdown, such as &lt;a href="https://statiq.dev/"&gt;Statiq&lt;/a&gt;, to create a beautiful documentation site for your modules.&lt;/p&gt;
&lt;h2 id="how-to-use-bri"&gt;How to use BRI?&lt;/h2&gt;
&lt;p&gt;BRI is very easy to use. You just need to install it from &lt;a href="https://www.nuget.org/packages/bri"&gt;NuGet.org&lt;/a&gt; using the &lt;a href="https://get.dot.net/"&gt;.NET SDK&lt;/a&gt; &lt;a href="https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-tool-install"&gt;tool install command&lt;/a&gt;. It supports both .NET 7 and .NET 8, and you can install it globally or locally. For example, to install it globally, you can run:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet tool install --global BRI
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or, to install it locally (tool manifest), you can run:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet tool install --local BRI
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once installed, you can run BRI by typing (&lt;code&gt;dotnet bri&lt;/code&gt; if installed locally):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;bri inventory &amp;lt;container registry name&amp;gt; &amp;lt;output path&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For example, to scan the container registry named myregistry.azurecr.io and generate markdown files in the ./output/path folder, you can run:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;bri inventory myregistry.azurecr.io ./output/path
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="example"&gt;Example&lt;/h2&gt;
&lt;p&gt;You can see an example of the output that BRI generates at &lt;a href="https://www.devlead.se/bri/britool.azurecr.io/bicep/modules/bri/4.0.0.0.html"&gt;www.devlead.se/bri/&lt;/a&gt;
&lt;a href="https://www.devlead.se/bri/britool.azurecr.io/bicep/modules/bri/4.0.0.0.html"&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2022/11/27/00ee924d-9de2-4b2b-90cc-1b5a8bcfb696_small.jpg?sv=2021-10-04&amp;amp;st=2023-11-27T19%3A39%3A50Z&amp;amp;se=2031-11-28T19%3A39%3A00Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=oree1I2Ia%2BqTdwXxZ1teSRHTf9iPODDLjjp5HvUGVsA%3D" alt="example" /&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="authentication"&gt;Authentication&lt;/h2&gt;
&lt;p&gt;By default, it'll try to authenticate using the &lt;a href="https://learn.microsoft.com/en-us/dotnet/api/azure.identity.defaultazurecredential?view=azure-dotnet"&gt;DefaultAzureCredential&lt;/a&gt; which tries to authorize in the following order based on your environment.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/azure.identity.environmentcredential?view=azure-dotnet"&gt;EnvironmentCredential&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/azure.identity.workloadidentitycredential?view=azure-dotnet"&gt;WorkloadIdentityCredential&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/azure.identity.managedidentitycredential?view=azure-dotnet"&gt;ManagedIdentityCredential&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/azure.identity.sharedtokencachecredential?view=azure-dotnet"&gt;SharedTokenCacheCredential&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/azure.identity.visualstudiocredential?view=azure-dotnet"&gt;VisualStudioCredential&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/azure.identity.visualstudiocodecredential?view=azure-dotnet"&gt;VisualStudioCodeCredential&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/azure.identity.azureclicredential?view=azure-dotnet"&gt;AzureCliCredential&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/azure.identity.azurepowershellcredential?view=azure-dotnet"&gt;AzurePowerShellCredential&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/azure.identity.azuredeveloperclicredential?view=azure-dotnet"&gt;AzureDeveloperCliCredential&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/azure.identity.interactivebrowsercredential?view=azure-dotnet"&gt;InteractiveBrowserCredential&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If running in a DevOps pipeline recommended way is to use a managed/workload identity, or create an Entra ID &lt;a href="https://learn.microsoft.com/en-us/entra/identity-platform/app-objects-and-service-principals?tabs=browser"&gt;service principal&lt;/a&gt; and set the following environment variables fetched from pipeline secrets&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;AZURE_TENANT_ID&lt;/code&gt; to its tenant ID&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AZURE_CLIENT_ID&lt;/code&gt; to its client ID&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AZURE_CLIENT_SECRET&lt;/code&gt; to its secret.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AZURE_AUTHORITY_HOST&lt;/code&gt; to &lt;code&gt;https://login.microsoftonline.com/&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="where-to-find-bri"&gt;Where to find BRI?&lt;/h2&gt;
&lt;p&gt;BRI is open source and licensed under the MIT license, so you can use it freely and modify it as you wish. You can find the source code on &lt;a href="https://github.com/devlead/BRI"&gt;GitHub&lt;/a&gt; and the NuGet package at &lt;a href="https://www.nuget.org/packages/bri"&gt;NuGet.org&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="feedback-and-suggestions"&gt;Feedback and suggestions&lt;/h2&gt;
&lt;p&gt;I hope you find BRI useful and that it helps you with your Bicep module development. If you have any feedback or suggestions, please feel free to open an issue or a pull request on GitHub. Happy coding!&lt;/p&gt;
</content>
		<summary>A DevOps tool to document Bicep modules in a Azure container registry</summary>
	</entry>
	<entry>
		<id>https://www.devlead.se/posts/2021/2021-09-23-joining-the-net-foundation-board-of-directors</id>
		<title>Joining the .NET Foundation Board of Directors</title>
		<author>
			<name>devlead</name>
		</author>
		<link href="https://www.devlead.se/posts/2021/2021-09-23-joining-the-net-foundation-board-of-directors" />
		<link rel="enclosure" type="image" href="https://cdn.devlead.se/clipimg-vscode/2021/09/23/468b4b6e-3ecd-c723-3323-8ffce93ac433.png?sv=2019-12-12&amp;st=2021-09-22T14%253A02%253A54Z&amp;se=2031-09-23T14%253A02%253A54Z&amp;sr=b&amp;sp=r&amp;sig=kN9k556DBbpI5pYPbI2tLDpXGiLFIJRsBsZ07Pf1LEc%253D" />
		<updated>2021-09-23T00:00:00Z</updated>
		<content>&lt;p&gt;Yesterday the .NET Foundation &lt;a href="https://dotnetfoundation.org/blog/2021/09/22/net-foundation-election-results-2021"&gt;announced&lt;/a&gt; the results from the 2021 Board of Directors Election. An election where the Foundation's members choose who they want to represent them on the board and this election set out to fill four out of seven seats.&lt;/p&gt;
&lt;p&gt;And I'm deeply honored to announce that I have this election been elected along with&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://dotnetfoundation.org/about/election/campaign-2021/frank-arkhurst-odoom"&gt;Frank Odoom&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://dotnetfoundation.org/about/election/campaign-2021/javier-lozano"&gt;Javier Lozano&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://dotnetfoundation.org/about/election/campaign-2021/rob-prouse"&gt;Rob Prouse&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="the-new-board-of-directors"&gt;The new Board of Directors&lt;/h2&gt;
&lt;p&gt;This means that as a result of the election the board will have the following members&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bill Wagner&lt;/li&gt;
&lt;li&gt;Frank Odoom&lt;/li&gt;
&lt;li&gt;Javier Lozano&lt;/li&gt;
&lt;li&gt;Mattias Karlsson&lt;/li&gt;
&lt;li&gt;Rich Lander&lt;/li&gt;
&lt;li&gt;Rob Prouse&lt;/li&gt;
&lt;li&gt;Shawn Wildermuth&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="changes-to-the-board-of-directors"&gt;Changes to the Board of Directors&lt;/h2&gt;
&lt;p&gt;Javier Lozano was re-elected, so leaving the board are&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Beth Massi&lt;/li&gt;
&lt;li&gt;Jeff Strauss&lt;/li&gt;
&lt;li&gt;Layla Porter&lt;/li&gt;
&lt;li&gt;Rodney Littles II&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Beth, Jeff, Layla, Rodney thanks you for your hard work! ❤️&lt;/p&gt;
&lt;h2 id="personal-reflections"&gt;Personal reflections&lt;/h2&gt;
&lt;p&gt;I'm truly humbled by the confidence placed in me by the Foundation members, so thank you!❤️&lt;/p&gt;
&lt;p&gt;I just got the news at the same time as the rest of the world, so I'm far from onboarded yet, and honestly don't have a 100% clear picture of what to expect and what's expected of me.&lt;/p&gt;
&lt;p&gt;But at the same time, I know too well how much hard and frustrating work it can be from years of experience participating in various boards, non-profits, communities, and open source projects. And I've got huge respect for the tasks and challenges at hand. The board speaks in one voice but consists of several voices, yours included.
There are several challenges we face, some issues may be small, others unacceptable which clearly need to be addressed, key problem areas in my mind are:&lt;/p&gt;
&lt;h3 id="diversity"&gt;Diversity&lt;/h3&gt;
&lt;p&gt;We need for the  .NET community to be welcoming safe, inclusive, and representative for current and new participants. And it's clear there's room for improvement here.
This includes the Board of Directors, which in my opinion isn't representative - so here we will need your, members, committees, and the community help to hold us accountable and provide us honest constructive feedback. We can be good allies and champions, even if we're not serving in any official capacity. And truly hope we'll have a more representative board post next election.&lt;/p&gt;
&lt;h3 id="sustainability"&gt;Sustainability&lt;/h3&gt;
&lt;p&gt;Sustainability isn't just about adding members, projects, and responsibilities, it's also what happens after you've joined or promises have been made. It's not sustainable if members, maintainers, and community leaders burn out, feel unwelcome or unheard. We can't grow if we at the same time have a churn of people and projects. Don't set things in motion you don't have a plan for how to maintain it - or clearly scope that it's time-limited.&lt;/p&gt;
&lt;h3 id="transparency"&gt;Transparency&lt;/h3&gt;
&lt;p&gt;For me, this is hugely centered around communication, only promise what you can deliver on, clearly communicate what can be expected and when to expect it. If you're unsure, clarify. If you can't communicate yet - communicate that - silence isn't respectful and just fuels misinformation.&lt;/p&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Thanks for the confidence! this will be an interesting journey, and truly hope I can represent you well. I will need some time to be the &amp;quot;new person&amp;quot; - hear people out, ask stupid questions, inventory which tools are at hand, and so on.&lt;/p&gt;
</content>
		<summary>A reflection on the results from the 2021 Board of Directors Election</summary>
	</entry>
	<entry>
		<id>https://www.devlead.se/posts/2021/2021-04-11-devlead-statiq-part3-includecode</id>
		<title>Devlead.Statiq - Part 3 - IncludeCode 🤺</title>
		<author>
			<name>devlead</name>
		</author>
		<link href="https://www.devlead.se/posts/2021/2021-04-11-devlead-statiq-part3-includecode" />
		<link rel="enclosure" type="image" href="https://cdn.devlead.se/clipimg-vscode/2021/04/08/985368ff-3b5e-5079-00b1-2d01c433f6b8.png?sv=2019-12-12&amp;st=2021-04-07T21%253A28%253A53Z&amp;se=2031-04-08T21%253A28%253A53Z&amp;sr=b&amp;sp=r&amp;sig=yJSMzQzEuAd%252B1IyVh9Hsn%252FBBJE4iLet9Ymg6nOqFmCA%253D" />
		<updated>2021-04-11T00:00:00Z</updated>
		<content>&lt;p&gt;So I'm lazy... when doing a blog post, or documentation I don't want to repeat my self, and a prime example of that is when documenting Statiq features I found my self to want to both display both the "source" and the "result" without having to type the same thing twice nor update in multiple places and that's why I created the &lt;code&gt;IncludeCode&lt;/code&gt; Shortcode and in this last of the three-part introductory blog post series about the NuGet package &lt;a href="https://www.nuget.org/packages/Devlead.Statiq"&gt;Devlead.Statiq&lt;/a&gt; I'll tell you all about it.&lt;/p&gt;
&lt;h2 id="includecode-shortcode"&gt;IncludeCode Shortcode&lt;/h2&gt;
&lt;p&gt;Code include shortcode - A Statiq &lt;a href="https://statiq.dev/framework/content/shortcodes"&gt;shortcode&lt;/a&gt; enables you fetch an external file into a markdown code fence block.&lt;/p&gt;
&lt;p&gt;Statiq comes with a built in &lt;code&gt;Include&lt;/code&gt; shortcode, which will just merge in the source of another document into the document utilizing the shortcode. This is really handy as it'll for example lets you edit content in one place, but you can use it in multiple places keeping things dry.&lt;/p&gt;
&lt;p&gt;The issue and feature with &lt;code&gt;Include&lt;/code&gt; is that it'll be executed as part of your Statiq App pipeline, any code in it will be rendered. Which might not be what you want for a code sample. So I created the &lt;code&gt;IncludeCode&lt;/code&gt; shortcode which will process and include the external document within a markdown code fence.&lt;/p&gt;
&lt;h3 id="example-usage"&gt;Example usage&lt;/h3&gt;
&lt;!--?# IncludeCode "./../includes/posts/2021/devlead-statiq/includecode/includecode.md" /?--&gt;
&lt;h3 id="result"&gt;Result&lt;/h3&gt;
&lt;!--?# Include "./../includes/posts/2021/devlead-statiq/includecode/includecode.md" /?--&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;IncludeCode&lt;/code&gt; shortcode is a small addition, but it keeps my content DRY which I've learned to really appreciate as it not only reduces typing, but also reduces risk of inconsistencies and errors.&lt;/p&gt;
&lt;h2 id="resources"&gt;Resources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Statiq
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/statiqdev"&gt;GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://statiq.dev/"&gt;Documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Devlead.Statiq
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/devlead/Devlead.Statiq"&gt;GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.nuget.org/packages/Devlead.Statiq/"&gt;NuGet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.devlead.se/posts/2021/2021-04-09-devlead-statiq-part1-tabs"&gt;Part 1 - Tabs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.devlead.se/posts/2021/2021-04-10-devlead-statiq-part2-theme-from-uri"&gt;Part 2 - Theme from external web resource&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.devlead.se/posts/2021/2021-04-11-devlead-statiq-part3-includecode"&gt;Part 3 - IncludeCode 🤺&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>An .NET assembly extending the static site generator Statiq with new core features</summary>
	</entry>
	<entry>
		<id>https://www.devlead.se/posts/2021/2021-04-10-devlead-statiq-part2-theme-from-uri</id>
		<title>Devlead.Statiq - Part 2 - Theme from external web resource</title>
		<author>
			<name>devlead</name>
		</author>
		<link href="https://www.devlead.se/posts/2021/2021-04-10-devlead-statiq-part2-theme-from-uri" />
		<link rel="enclosure" type="image" href="https://cdn.devlead.se/clipimg-vscode/2021/04/08/04e3408e-5295-3d37-0421-11c3ec60a691.png?sv=2019-12-12&amp;st=2021-04-07T20%253A30%253A55Z&amp;se=2031-04-08T20%253A30%253A55Z&amp;sr=b&amp;sp=r&amp;sig=VI8xA0tYLfkNIsS%252FQx%252B9HDbDPU3n1TckpRJFflxg4sg%253D" />
		<updated>2021-04-10T00:00:00Z</updated>
		<content>&lt;p&gt;Sometimes you just want things your way, in this second part of the three-part introductory blog post series about the NuGet package &lt;a href="https://www.nuget.org/packages/Devlead.Statiq"&gt;Devlead.Statiq&lt;/a&gt;, I'll go through how it can enable having your Statiq web theme reside as a common external web resource.&lt;/p&gt;
&lt;h2 id="the-problem"&gt;The problem&lt;/h2&gt;
&lt;p&gt;Themes in Statiq are essentially a folder alongside your &lt;code&gt;input&lt;/code&gt; folder. An example of such a theme is &lt;a href="https://github.com/statiqdev/CleanBlog"&gt;statiqdev/CleanBlog&lt;/a&gt;, the official recommended way to use it as a GIT sub-module like below&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git submodule add https://github.com/statiqdev/CleanBlog.git theme
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But I wanted a way to just clone and build without the hassle of sub-modules, but I also didn't want to just "copy-and-paste" the theme. I still wanted to with ease take the benefits of any updates to the upstream repository.&lt;/p&gt;
&lt;h2 id="the-solution"&gt;The solution&lt;/h2&gt;
&lt;p&gt;My solution ended up to extend Statiq so I could just configure the theme to a specific external uri, pointing to a web resource containing a zip archive of that theme, and Statiq would then transparently download, extract and cache that theme as the site was generated. Changing the uri would invalidate the cache and fetch the theme again.&lt;/p&gt;
&lt;p&gt;Fortunately, GitHub provides the functionality to serve any commit/tag/release as a zip archive using the &lt;code&gt;https://github.com/{owner}/{repo}/archive/{reference}&lt;/code&gt; syntax, i.e. &lt;code&gt;https://github.com/statiqdev/CleanBlog/archive/ceb5055f3d0f7a330708494ed21eb469cde62ce2.zip&lt;/code&gt;, making it really easy to obtain a specific immutable version of an upstream theme.&lt;/p&gt;
&lt;p&gt;I then "gitignored" my &lt;code&gt;theme&lt;/code&gt; folder - so it would never be added to the site's repository. I made sure any site-specific modifications only existed within my Statiq content &lt;code&gt;input&lt;/code&gt; folder - ensuring new versions of the theme could be fetched without losing my tweaks to the theme.&lt;/p&gt;
&lt;h2 id="example-usage"&gt;Example usage&lt;/h2&gt;
&lt;p&gt;First of all in your Statiq App you need to add the &lt;a href="https://www.nuget.org/packages/Devlead.Statiq"&gt;Devlead.Statiq&lt;/a&gt; NuGet package to your Statiq web application.&lt;/p&gt;
&lt;p&gt;Then theme from uri support in Statiq is enabled like below by invoking the &lt;code&gt;AddThemeFromUri&lt;/code&gt; extension on the Statiq app &lt;a href="https://statiq.dev/framework/configuration/bootstrapper/"&gt;Bootstrapper&lt;/a&gt;, and as a parameter to it specifying the uri where the theme zip archive is located&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using System;
using Devlead.Statiq.Themes;
using Statiq.App;
using Statiq.Common;
using Statiq.Web;

await Bootstrapper
    .Factory
    .CreateDefault(args)
    .AddThemeFromUri(new Uri("https://github.com/statiqdev/CleanBlog/archive/ceb5055f3d0f7a330708494ed21eb469cde62ce2.zip"))
    .AddWeb()
    .RunAsync();

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;IMHO this results in a fairly clean way to reuse themes between sites and makes it easy to contribute to a site using this method - all the setup a contributor needs to be able to test/preview the site clone the repository and run the project.&lt;/p&gt;
&lt;h2 id="resources"&gt;Resources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Statiq
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/statiqdev"&gt;GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://statiq.dev/"&gt;Documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Devlead.Statiq
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/devlead/Devlead.Statiq"&gt;GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.nuget.org/packages/Devlead.Statiq/"&gt;NuGet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.devlead.se/posts/2021/2021-04-09-devlead-statiq-part1-tabs"&gt;Part 1 - Tabs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.devlead.se/posts/2021/2021-04-10-devlead-statiq-part2-theme-from-uri"&gt;Part 2 - Theme from external web resource&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.devlead.se/posts/2021/2021-04-11-devlead-statiq-part3-includecode"&gt;Part 3 - IncludeCode 🤺&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>An .NET assembly extending the static site generator Statiq with new core features</summary>
	</entry>
	<entry>
		<id>https://www.devlead.se/posts/2021/2021-04-09-devlead-statiq-part1-tabs</id>
		<title>Devlead.Statiq - Part 1 - Tabs</title>
		<author>
			<name>devlead</name>
		</author>
		<link href="https://www.devlead.se/posts/2021/2021-04-09-devlead-statiq-part1-tabs" />
		<link rel="enclosure" type="image" href="https://cdn.devlead.se/clipimg-vscode/2021/04/05/390eeb4b-ad66-7406-860f-44ed05918873.png?sv=2019-12-12&amp;st=2021-04-04T18%253A20%253A27Z&amp;se=2031-04-05T18%253A20%253A27Z&amp;sr=b&amp;sp=r&amp;sig=yLJRew2YKzfdLNObjcb3I6kkwfWiegYX%252FP68MwmoX3k%253D" />
		<updated>2021-04-09T00:00:00Z</updated>
		<content>&lt;p&gt;Earlier this year I blogged about that my &lt;a href="https://www.devlead.se/posts/2021/2021-01-11-blog-migrated-to-statiq"&gt;"Blog migrated to Statiq"&lt;/a&gt;, one advantage with &lt;a href="https://statiq.dev/"&gt;Statiq&lt;/a&gt; is that it's through .NET code really customizable and lets you adapt it fully to your needs. Code that can be packaged and distributed as a NuGet package, making it straightforward to share and reuse functionality between sites.&lt;br&gt; &lt;br&gt; In a three-part blog post series, I'll start going through the features of the NuGet package &lt;a href="https://www.nuget.org/packages/Devlead.Statiq"&gt;Devlead.Statiq&lt;/a&gt; created for my own Statiq based sites - but probably useful for others too, and this first part will be about the TabGroup Shortcode.&lt;/p&gt;
&lt;h2 id="tabgroup-shortcode"&gt;TabGroup Shortcode&lt;/h2&gt;
&lt;!--?# TabGroup ?--&gt;
&lt;!--?*
tabs:
  - name: Introduction
    content: |
      Statiq [shortcodes](https://statiq.dev/framework/content/shortcodes) are small but powerful macros that can generate content or add metadata to your documents.

      The `TabGroup` shortcode, is a CSS-only solution to simplify adding tabs in your Statiq input files.

      Why add tabs? Well with some content, a good example of that is code samples, tabs make it easier to group content together, keep things more focused and reduce user vertical scrolling.

      With the `TabGroup` shortcode tab content can be defined as either

      - Content - markdown defined directly in the shortcode content
      - Include - markdown fetched and processed from a external file
      - Code - fetch external file into markdown code fence

      the shortcode content is defined as `YAML`, you can within a single tab combine all variants (`content`, `include`, and `code`), and it'll render in the following order

      1. `content`
      1. `include`
      1. `code`

  - include: ./../includes/posts/2021/devlead-statiq/tabgroup/prerequisites.md

  - include: ./../includes/posts/2021/devlead-statiq/tabgroup/content.md

  - include: ./../includes/posts/2021/devlead-statiq/tabgroup/include.md

  - include: ./../includes/posts/2021/devlead-statiq/tabgroup/code.md

?--&gt;
&lt;!--?#/ TabGroup ?--&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;I'm really happy how flexible and versatile the &lt;code&gt;TabGroup&lt;/code&gt; shortcode ended up being, while still keeping my markdown files nice and tidy, abstracting away the complexity.&lt;/p&gt;
&lt;h2 id="resources"&gt;Resources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Statiq
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/statiqdev"&gt;GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://statiq.dev/"&gt;Documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Devlead.Statiq
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/devlead/Devlead.Statiq"&gt;GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.nuget.org/packages/Devlead.Statiq/"&gt;NuGet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.devlead.se/posts/2021/2021-04-09-devlead-statiq-part1-tabs"&gt;Part 1 - Tabs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.devlead.se/posts/2021/2021-04-10-devlead-statiq-part2-theme-from-uri"&gt;Part 2 - Theme from external web resource&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.devlead.se/posts/2021/2021-04-11-devlead-statiq-part3-includecode"&gt;Part 3 - IncludeCode 🤺&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>An .NET assembly extending the static site generator Statiq with new core features</summary>
	</entry>
	<entry>
		<id>https://www.devlead.se/posts/2021/2021-03-20-introducing-dpi</id>
		<title>Introducing DPI</title>
		<author>
			<name>devlead</name>
		</author>
		<link href="https://www.devlead.se/posts/2021/2021-03-20-introducing-dpi" />
		<link rel="enclosure" type="image" href="https://cdn.devlead.se/clipimg-vscode/2021/03/16/5e783ec1-b7cf-aaac-bf41-582e4110dfa9.png?sv=2019-12-12&amp;st=2021-03-15T19%253A51%253A42Z&amp;se=2031-03-16T19%253A51%253A42Z&amp;sr=b&amp;sp=r&amp;sig=0jvdk30dmb7ba7dKnLlfNMvY32nKHI1kqCxXzz3VhXo%253D" />
		<updated>2021-03-20T00:00:00Z</updated>
		<content>&lt;p&gt;When brought in as DevOps consultant or a new employee for that matter, one is often tasked with getting a clear picture of the current state of projects, how they work and fit together.&lt;br /&gt;&lt;br /&gt;
A big part of this initial and ongoing is to analyze and audit dependencies, which is why I've created &lt;code&gt;dpi&lt;/code&gt; a tool that both locally and as part of your DevOps pipeline can analyze your repository projects dependencies and report to Azure Log Analytics, console, and files.&lt;/p&gt;
&lt;h2 id="the-tools-initial-scope"&gt;The tool's initial scope&lt;/h2&gt;
&lt;p&gt;In this initial version, focus has been fairly complete support for C# .NET NuGet package dependencies, and the tool currently supports analyzing and reporting NuGet package dependencies for:&lt;/p&gt;
&lt;ul class="contains-task-list"&gt;
&lt;li class="task-list-item"&gt;&lt;input disabled="disabled" type="checkbox" checked="checked" /&gt; C# project files&lt;/li&gt;
&lt;li class="task-list-item"&gt;&lt;input disabled="disabled" type="checkbox" checked="checked" /&gt; MS Build Project assets&lt;/li&gt;
&lt;li class="task-list-item"&gt;&lt;input disabled="disabled" type="checkbox" checked="checked" /&gt; NuGet Package config files&lt;/li&gt;
&lt;li&gt;Cake script
&lt;ul class="contains-task-list"&gt;
&lt;li class="task-list-item"&gt;&lt;input disabled="disabled" type="checkbox" checked="checked" /&gt; Addins&lt;/li&gt;
&lt;li class="task-list-item"&gt;&lt;input disabled="disabled" type="checkbox" checked="checked" /&gt; Tools&lt;/li&gt;
&lt;li class="task-list-item"&gt;&lt;input disabled="disabled" type="checkbox" checked="checked" /&gt; Modules&lt;/li&gt;
&lt;li class="task-list-item"&gt;&lt;input disabled="disabled" type="checkbox" checked="checked" /&gt; Recipes&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="tool-value-proposition"&gt;Tool value proposition?&lt;/h2&gt;
&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/03/17/0f47c134-5029-94f4-7a4e-07d4cd5b5d77.png?sv=2019-12-12&amp;st=2021-03-16T20%3A08%3A30Z&amp;se=2031-03-17T20%3A08%3A30Z&amp;sr=b&amp;sp=r&amp;sig=ZXq2a0u1x0ows1MPnkzgCWtLMz8fjvJLXvGtyVeu0dE%3D" alt="KQL Collage" align="right" width="600" height="426" /&gt;
&lt;p&gt;Analyzing and reporting dependencies to a central place enables you to discover, correlate, and aggregate dependencies across multiple locations. &lt;code&gt;dpi&lt;/code&gt; reports its findings to an Azure Log Analytics workspace, which provides an efficient way to store and query large amounts of tabular data using &lt;a href="https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/?WT.mc_id=AZ-MVP-5002677"&gt;KQL - Kusto Query Language&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This enables you to quickly tackle several scenarios i.e&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Find which repositories have certain dependencies&lt;/li&gt;
&lt;li&gt;Identify which versions of dependencies used&lt;/li&gt;
&lt;li&gt;Most / least used dependencies&lt;/li&gt;
&lt;li&gt;If a dependency is used anywhere&lt;/li&gt;
&lt;li&gt;Follow dependency usage over time&lt;/li&gt;
&lt;li&gt;Only limited outbound/one-way http traffic with analytics data to one common endpoint&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h2 id="acquiring-the-tool"&gt;Acquiring the tool&lt;/h2&gt;
&lt;h3 id="requirements"&gt;Requirements&lt;/h3&gt;
&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/03/18/64b64f7a-9eaa-3753-71e5-781a58a6d188.png?sv=2019-12-12&amp;st=2021-03-17T17%3A08%3A25Z&amp;se=2031-03-18T17%3A08%3A25Z&amp;sr=b&amp;sp=r&amp;sig=1iNd2EAsow19wsG8M2Av69Y52BjqUpzKl13bXiQxZ%2FY%3D" alt="Azure Log Analytics Workspace Agents management" align="right" /&gt;
&lt;p&gt;&lt;code&gt;dpi&lt;/code&gt; is a .NET 5 Tool, so .NET 5 SDK is required to be installed - you can find the download and install the latest version of the .NET SDK from &lt;a href="https://get.dot.net/"&gt;get.dot.net&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The tool is published to and distributed via &lt;a href="https://www.nuget.org/packages/DPI/"&gt;NuGet.org&lt;/a&gt;, but you could also upload it to your internal NuGet feed and have your users and pipelines obtain it from there.&lt;/p&gt;
&lt;p&gt;To report you also need an Azure Log Analytics workspace, and the tool uses Workspace Id and Key (either primary or secondary, both work), you'll find those under &amp;quot;Agents management&amp;quot;&lt;/p&gt;
&lt;br /&gt;
&lt;h3 id="installing-globally"&gt;Installing globally&lt;/h3&gt;
&lt;p&gt;.NET Tools can be installed globally for the current user using the .NET SDK CLI&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet tool install --global DPI
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once installed the tool will be available anywhere for the current user as &lt;code&gt;dotnet tool run dpi&lt;/code&gt;, &lt;code&gt;dotnet dpi&lt;/code&gt;, or just &lt;code&gt;dpi&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id="installing-via-tool-manifest"&gt;Installing via Tool manifest&lt;/h3&gt;
&lt;p&gt;My preferred way to install and maintain a .NET tool is using a .NET local tool manifest file added to your repository, this means which tools are used and their specific versions is maintained within the repository.&lt;/p&gt;
&lt;p&gt;If you don't have a manifest in your repository already, the easiest way to create a new manifest is by using the .NET SDK CLI in your repo root.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet new tool-manifest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;then or if you already have a manifest you add the tool&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet tool install DPI
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the tool is now within the repository available as &lt;code&gt;dotnet tool run dpi&lt;/code&gt; or &lt;code&gt;dotnet dpi&lt;/code&gt;, then your pipelines and anyone cloning your repository can obtain all your specified tools with the same versions as you're using by executing&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet tool restore
&lt;/code&gt;&lt;/pre&gt;
&lt;br /&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;h3 id="nuget-analyze-command"&gt;NuGet Analyze command&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;dpi nuget [SourcePath] [NUGET OPTIONS] analyze [ANALYZE OPTIONS]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The NuGet analyze command will inventory the specified path recursively for known files containing references to NuGet packages and output its findings to the console, the current directory will be used if no path specified.&lt;/p&gt;
&lt;h4 id="example-analyzing-current-directory"&gt;Example analyzing current directory&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet dpi nuget analyze
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="example-analyzing-specific-directory"&gt;Example analyzing specific directory&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet dpi nuget ./path/to/folder analyze
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="nuget-report-command"&gt;NuGet Report command&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;dpi nuget [SourcePath] [NUGET OPTIONS] report [REPORT OPTIONS]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The NuGet report command will beyond analyze also report tools findings as a custom log to Azure Log Analytics.&lt;/p&gt;
&lt;h4 id="example-analyzing-and-reporting-current-directory"&gt;Example analyzing and reporting current directory&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet dpi nuget report --workspace &amp;lt;WORKSPACEID&amp;gt; --sharedkey &amp;lt;SHAREDKEY&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="example-analyzing-and-reporting-specific-directory"&gt;Example analyzing and reporting specific directory&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet dpi nuget ./path/to/folder report --workspace &amp;lt;WORKSPACEID&amp;gt; --sharedkey &amp;lt;SHAREDKEY&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Azure Log Analytics Workspace ID and Key can also be passed as environment variables &lt;code&gt;NuGetReportSettings_WorkspaceId&lt;/code&gt; and &lt;code&gt;NuGetReportSettings_SharedKey&lt;/code&gt;, which is the preferred way when passing secrets in a DevOps pipeline, the result of nuget analyze is reported to custom log &lt;code&gt;NuGetReport_CL&lt;/code&gt; in the specified workspace.&lt;/p&gt;
&lt;h3 id="console-output-formats"&gt;Console output formats&lt;/h3&gt;
&lt;p&gt;By using the &lt;code&gt;--output &amp;lt;FORMAT&amp;gt;&lt;/code&gt; option you can change the console output of the tools analyze result, currently, the tool supports the following formats&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JSON - output in a machine consumable JSON format&lt;/li&gt;
&lt;li&gt;TABLE - outputs a nicely formatted table format&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(You can use the &lt;code&gt;--file &amp;lt;FILEPATH&amp;gt;&lt;/code&gt; option to output to file instead of console)&lt;/p&gt;
&lt;h4 id="example-analyzing-and-outputting-as-json"&gt;Example analyzing and outputting as json&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet dpi nuget --output json analyze
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;[
  {
    &amp;quot;sessionId&amp;quot;: &amp;quot;b770baf0-8eb7-496f-aa19-770f36838689&amp;quot;,
    &amp;quot;buildProvider&amp;quot;: &amp;quot;Local&amp;quot;,
    &amp;quot;platformFamily&amp;quot;: &amp;quot;Windows&amp;quot;,
    &amp;quot;buildNo&amp;quot;: &amp;quot;202103181806&amp;quot;,
    &amp;quot;buildSCM&amp;quot;: &amp;quot;dpi&amp;quot;,
    &amp;quot;buildVersion&amp;quot;: null,
    &amp;quot;sourceType&amp;quot;: &amp;quot;CSProj&amp;quot;,
    &amp;quot;source&amp;quot;: &amp;quot;TestProj/TestProj.csproj&amp;quot;,
    &amp;quot;targetFramework&amp;quot;: &amp;quot;net5.0&amp;quot;,
    &amp;quot;packageId&amp;quot;: &amp;quot;Microsoft.Extensions.DependencyInjection&amp;quot;,
    &amp;quot;version&amp;quot;: &amp;quot;5.0.1&amp;quot;,
    &amp;quot;timestamp&amp;quot;: &amp;quot;2021-03-18T18:06:30.0178489+00:00&amp;quot;,
    &amp;quot;Computer&amp;quot;: &amp;quot;HAL&amp;quot;
  },
  {
    &amp;quot;sessionId&amp;quot;: &amp;quot;b770baf0-8eb7-496f-aa19-770f36838689&amp;quot;,
    &amp;quot;buildProvider&amp;quot;: &amp;quot;Local&amp;quot;,
    &amp;quot;platformFamily&amp;quot;: &amp;quot;Windows&amp;quot;,
    &amp;quot;buildNo&amp;quot;: &amp;quot;202103181806&amp;quot;,
    &amp;quot;buildSCM&amp;quot;: &amp;quot;dpi&amp;quot;,
    &amp;quot;buildVersion&amp;quot;: null,
    &amp;quot;sourceType&amp;quot;: &amp;quot;CSProj&amp;quot;,
    &amp;quot;source&amp;quot;: &amp;quot;TestProj/TestProj.csproj&amp;quot;,
    &amp;quot;targetFramework&amp;quot;: &amp;quot;net5.0&amp;quot;,
    &amp;quot;packageId&amp;quot;: &amp;quot;Cake.Core&amp;quot;,
    &amp;quot;version&amp;quot;: &amp;quot;1.1.0&amp;quot;,
    &amp;quot;timestamp&amp;quot;: &amp;quot;2021-03-18T18:06:30.0178489+00:00&amp;quot;,
    &amp;quot;Computer&amp;quot;: &amp;quot;HAL&amp;quot;
  }
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This means that you as an example in PowerShell could do something like the below script to get all versions of &lt;code&gt;YamlDotNet&lt;/code&gt; used.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;dotnet dpi nuget --output json analyze `
  | ConvertFrom-Json `
  | ForEach-Object { $_ } `
  | Where-Object { $_.packageId -eq 'YamlDotNet' } `
  | ForEach-Object version
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="example-analyzing-and-outputting-as-table"&gt;Example analyzing and outputting as table&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet dpi nuget --output table analyze
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/03/18/2465161d-a1c7-5401-b67e-8d84cf66911a.png?sv=2019-12-12&amp;amp;st=2021-03-17T18%3A21%3A33Z&amp;amp;se=2031-03-18T18%3A21%3A33Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=hsF2ReevVLx3mEaRmTumGikNQGuAJNGVD3FDB7zEOWM%3D" alt="Console example dpi table format" /&gt;&lt;/p&gt;
&lt;br /&gt;
&lt;h2 id="pipeline-examples"&gt;Pipeline examples&lt;/h2&gt;
&lt;p&gt;As &lt;code&gt;dpi&lt;/code&gt; is just a command-line tool, you can just use the same commands in your build pipeline as you use in your shell of choice locally.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;dotnet tool restore&lt;/code&gt; - Restore .NET Tools (i.e. download and install &lt;code&gt;dpi&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dotnet dpi &amp;lt;COMMAND&amp;gt; [COMMAND OPTIONS] &amp;lt;SUBCOMMAND&amp;gt; [SUB COMMAND OPTIONS]&lt;/code&gt; - Execute &lt;code&gt;dpi&lt;/code&gt; i.e. &lt;code&gt;nuget&lt;/code&gt; &lt;code&gt;analyze&lt;/code&gt; / &lt;code&gt;report&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The below pipeline examples you'll see two options not previously mentioned&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--silent&lt;/code&gt; - Silent removes all console log output except the &lt;code&gt;table&lt;/code&gt; (&lt;code&gt;json&lt;/code&gt; will bet &amp;quot;silent&amp;quot; by default so output can be parsed by another tool.)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--buildversion&lt;/code&gt; - Build version is an option to pass metadata unique to the workflow, in this case, the unique run number from GitHub Action workflow, but could i.e. be asserted version from a tool like GitVersion.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="github-action-workflow-example"&gt;GitHub Action workflow example&lt;/h3&gt;
&lt;p&gt;Below YAML example will&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Checks out code from the repository&lt;/li&gt;
&lt;li&gt;Installs .NET SDK based on &lt;a href="https://docs.microsoft.com/en-us/dotnet/core/tools/global-json?WT.mc_id=DT-MVP-5002677"&gt;global.json&lt;/a&gt; in repository&lt;/li&gt;
&lt;li&gt;Restore .NET Tools (i.e. &lt;code&gt;dpi&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Build project&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dpi&lt;/code&gt; Analyze if secrets &lt;strong&gt;aren't&lt;/strong&gt; available (i.e. a fork pull request)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dpi&lt;/code&gt; Report if secrets &lt;strong&gt;are&lt;/strong&gt; available (i.e. merged into &lt;code&gt;main&lt;/code&gt;)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;name: Build
on:
  pull_request:
  push:
    branches:
      - main

env:
  NuGetReportSettings_SharedKey: ${{ secrets.NUGETREPORTSETTINGS_SHAREDKEY }}
  NuGetReportSettings_WorkspaceId: ${{ secrets.NUGETREPORTSETTINGS_WORKSPACEID }}

jobs:
  build:
    runs-on: windows-latest
    steps:
      - name: Get the sources
        uses: actions/checkout&amp;#64;v2

      - name: Install .NET Core SDK
        uses: actions/setup-dotnet&amp;#64;v1

      - name: Restore .NET Tools
        run: dotnet tool restore

      - name: Build Project
        run: dotnet build

      - name: Run DPI Analyze
        if: ${{ env.NuGetReportSettings_SharedKey == null || env.NuGetReportSettings_WorkspaceId == null }}
        shell: bash
        run: dotnet dpi nuget --silent --output table analyze --buildversion $GITHUB_RUN_NUMBER

      - name: Run DPI Report
        if: ${{ env.NuGetReportSettings_SharedKey != null &amp;amp;&amp;amp; env.NuGetReportSettings_WorkspaceId != null }}
        shell: bash
        run: dotnet dpi nuget --silent --output table report --buildversion $GITHUB_RUN_NUMBER
&lt;/code&gt;&lt;/pre&gt;
&lt;br /&gt;
&lt;h3 id="azure-devops-pipelines-example"&gt;Azure DevOps Pipelines example&lt;/h3&gt;
&lt;p&gt;Below YAML example will&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Checks out code from the repository&lt;/li&gt;
&lt;li&gt;Installs .NET SDK based on &lt;a href="https://docs.microsoft.com/en-us/dotnet/core/tools/global-json?WT.mc_id=DT-MVP-5002677"&gt;global.json&lt;/a&gt; in the repository&lt;/li&gt;
&lt;li&gt;Restore .NET Tools (i.e. &lt;code&gt;dpi&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Build project&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dpi&lt;/code&gt; Analyze if it's a pull request&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dpi&lt;/code&gt; Report if executing in the &lt;code&gt;main&lt;/code&gt; branch&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;name: $(Year:yyyy).$(Month).$(DayOfMonth)$(Rev:.r)
trigger:
- main

pool:
  vmImage: 'windows-latest'

steps:
- task: UseDotNet&amp;#64;2
  displayName: 'Install .NET Core SDK'
  inputs:
    packageType: sdk
    useGlobalJson: true

- script: dotnet tool restore
  displayName: 'Restore .NET Tools'

- script: dotnet build src
  displayName: 'Build Project'

- script: dotnet dpi nuget --silent --output table analyze --buildversion &amp;quot;$(Build.BuildNumber)&amp;quot;
  displayName: Run DPI Analyze
  condition: eq(variables['Build.Reason'], 'PullRequest')

- script: dotnet dpi nuget --silent --output table report --buildversion &amp;quot;$(Build.BuildNumber)&amp;quot;
  displayName: Run DPI Report
  env:
    NuGetReportSettings_SharedKey: $(NUGETREPORTSETTINGS_SHAREDKEY)
    NuGetReportSettings_WorkspaceId: $(NUGETREPORTSETTINGS_WORKSPACEID)
  condition: eq(variables['Build.SourceBranch'], 'refs/heads/main')
&lt;/code&gt;&lt;/pre&gt;
&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/03/19/659e0331-59b9-a7b6-1a72-81c04208beaa.png?sv=2019-12-12&amp;st=2021-03-18T12%3A51%3A01Z&amp;se=2031-03-19T12%3A51%3A01Z&amp;sr=b&amp;sp=r&amp;sig=zEkSEyMfWQ5u4lJLxrPQHgooMxD10VmDNijiwnGkax0%3D" alt="Azure Pipelines Secrets" align="right" /&gt;
&lt;br /&gt;
&lt;p&gt;In the above example, the Azure Log Analytics Workspace Key and Id are passed as environment variables&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NuGetReportSettings_SharedKey&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NuGetReportSettings_WorkspaceId&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;which are populated from pipeline secret variables&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NUGETREPORTSETTINGS_SHAREDKEY&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NUGETREPORTSETTINGS_WORKSPACEID&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Pipeline variables are administrated under your Pipeline details -&amp;gt; Edit -&amp;gt; Variables, they're made secrets by checking the &amp;quot;Keep this value secret&amp;quot; checkbox.&lt;/p&gt;
&lt;p&gt;Secrets need to be explicitly defined in YAML to be accessible from tasks.&lt;/p&gt;
&lt;br /&gt;
&lt;h3 id="cake-build-examples"&gt;Cake build examples&lt;/h3&gt;
&lt;p&gt;There's not yet a Cake addin or built-in support for &lt;code&gt;dpi&lt;/code&gt;, but still, it's fairly straightforward to use &lt;code&gt;dpi&lt;/code&gt; from a Cake script.&lt;/p&gt;
&lt;h4 id="example-cake-script-dpi-installed-globally-via.net-tool-manifest"&gt;Example Cake script DPI installed globally / via .NET tool manifest&lt;/h4&gt;
&lt;p&gt;The Cake script below will&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Setup context
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Version&lt;/code&gt; - Date based here but normally fetched from build provider or asserted from a tool (&lt;em&gt;i.e. GitVersion&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Analyze&lt;/code&gt; - flag for if &lt;code&gt;analyze&lt;/code&gt; or &lt;code&gt;report&lt;/code&gt; based on presence of environment variables&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Build project&lt;/li&gt;
&lt;li&gt;Analyze or Report based on context &lt;code&gt;Analyze&lt;/code&gt; flag&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public record BuildData(string Version, bool Analyze);

Setup(
  static context =&amp;gt; new BuildData(
    Version: FormattableString.Invariant(
                $&amp;quot;{DateTime.UtcNow:yyyy.M.d}&amp;quot;
              ),
    Analyze: new[] {
              &amp;quot;NuGetReportSettings_SharedKey&amp;quot;,
              &amp;quot;NuGetReportSettings_WorkspaceId&amp;quot;
            }
            .Select(key =&amp;gt; context.EnvironmentVariable(key))
            .Where(string.IsNullOrWhiteSpace)
            .Any()
  )
);

Task(&amp;quot;Build&amp;quot;)
    .Does&amp;lt;BuildData&amp;gt;(
        static (context, data) =&amp;gt; context.DotNetCoreBuild(
          &amp;quot;src&amp;quot;,
          new DotNetCoreBuildSettings {
            MSBuildSettings = new DotNetCoreMSBuildSettings()
              .WithProperty(&amp;quot;Version&amp;quot;, data.Version)
          }
    )
  );

Task(&amp;quot;DPI&amp;quot;)
  .IsDependentOn(&amp;quot;Build&amp;quot;)
  .Does&amp;lt;BuildData&amp;gt;(
      static (context, data) =&amp;gt; context.DotNetCoreTool(
        &amp;quot;dpi&amp;quot;,
        new DotNetCoreToolSettings {
            ArgumentCustomization = args =&amp;gt; args
                                              .Append(&amp;quot;nuget&amp;quot;)
                                              .Append(&amp;quot;--silent&amp;quot;)
                                              .AppendSwitchQuoted(&amp;quot;--output&amp;quot;, &amp;quot;table&amp;quot;)
                                              .Append(data.Analyze ? &amp;quot;analyze&amp;quot; : &amp;quot;report&amp;quot;)
                                              .AppendSwitchQuoted(&amp;quot;--buildversion&amp;quot;, data.Version)
        }
      )
  );

Task(&amp;quot;Default&amp;quot;)
  .IsDependentOn(&amp;quot;DPI&amp;quot;);

RunTarget(Argument(&amp;quot;target&amp;quot;, &amp;quot;Default&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="example-self-contained-cake-script"&gt;Example Self-contained Cake script&lt;/h4&gt;
&lt;p&gt;The Cake script below will&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Install the specified version of &lt;code&gt;dpi&lt;/code&gt; into Cake tool directory from NuGet&lt;/li&gt;
&lt;li&gt;Setup context
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Version&lt;/code&gt; - Date based here but normally fetched from build provider or asserted from a tool (&lt;em&gt;i.e. GitVersion&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Analyze&lt;/code&gt; - flag for if &lt;code&gt;analyze&lt;/code&gt; or &lt;code&gt;report&lt;/code&gt; based on presence of environment variables&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Build project&lt;/li&gt;
&lt;li&gt;Analyze or Report based on context &lt;code&gt;Analyze&lt;/code&gt; flag&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;#tool dotnet:?package=DPI&amp;amp;version=2021.3.16.28

public record BuildData(string Version, bool Analyze);

Setup(
  static context =&amp;gt; new BuildData(
    Version: FormattableString.Invariant(
                $&amp;quot;{DateTime.UtcNow:yyyy.M.d}&amp;quot;
              ),
    Analyze: new[] {
              &amp;quot;NuGetReportSettings_SharedKey&amp;quot;,
              &amp;quot;NuGetReportSettings_WorkspaceId&amp;quot;
            }
            .Select(key =&amp;gt; context.EnvironmentVariable(key))
            .Where(string.IsNullOrWhiteSpace)
            .Any()
  )
);

Task(&amp;quot;Build&amp;quot;)
    .Does&amp;lt;BuildData&amp;gt;(
        static (context, data) =&amp;gt; context.DotNetCoreBuild(
          &amp;quot;src&amp;quot;,
          new DotNetCoreBuildSettings {
            MSBuildSettings = new DotNetCoreMSBuildSettings()
              .WithProperty(&amp;quot;Version&amp;quot;, data.Version)
          }
    )
  );

Task(&amp;quot;DPI&amp;quot;)
  .IsDependentOn(&amp;quot;Build&amp;quot;)
  .Does&amp;lt;BuildData&amp;gt;(
      static (context, data) =&amp;gt; context.StartProcess(
        context.Tools.Resolve(&amp;quot;dpi&amp;quot;) ?? context.Tools.Resolve(&amp;quot;dpi.exe&amp;quot;),
        new ProcessSettings {
            Arguments = new ProcessArgumentBuilder()
                                                .Append(&amp;quot;nuget&amp;quot;)
                                                .Append(&amp;quot;--silent&amp;quot;)
                                                .AppendSwitchQuoted(&amp;quot;--output&amp;quot;, &amp;quot;table&amp;quot;)
                                                .Append(data.Analyze ? &amp;quot;analyze&amp;quot; : &amp;quot;report&amp;quot;)
                                                .AppendSwitchQuoted(&amp;quot;--buildversion&amp;quot;, data.Version)
        }
    )
  );

Task(&amp;quot;Default&amp;quot;)
  .IsDependentOn(&amp;quot;DPI&amp;quot;);

RunTarget(Argument(&amp;quot;target&amp;quot;, &amp;quot;Default&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;
&lt;br /&gt;
&lt;h2 id="analyzing-the-data"&gt;Analyzing the data&lt;/h2&gt;
&lt;p&gt;NuGet package references end up as a custom log named &lt;code&gt;NuGetReport_CL&lt;/code&gt; in your Azure Log Analytics Workspace, it will automatically as data is ingested infer types (&lt;code&gt;dates&lt;/code&gt;,&lt;code&gt;strings&lt;/code&gt;, &lt;code&gt;guids&lt;/code&gt;, etc.) and using &lt;a href="https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/?WT.mc_id=AZ-MVP-5002677"&gt;KQL (Kusto Query Language)&lt;/a&gt; you can now start to explore discover, correlate and aggregate.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/03/19/927adaa4-2902-74f1-e587-44377b7131e2.png?sv=2019-12-12&amp;amp;st=2021-03-18T14%3A49%3A47Z&amp;amp;se=2031-03-19T14%3A49%3A47Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=4eUp0%2F4y2jRxH1rCXJbz25%2BteDLSKSuiNv0V9oWti20%3D" alt="Azure Log Analytics Workspace General Logs NuGetReport_CL" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;(Tip there's a &lt;a href="https://docs.microsoft.com/en-us/azure/azure-monitor/logs/log-analytics-tutorial?WT.mc_id=AZ-MVP-5002677"&gt;Log Analytics tutorial&lt;/a&gt; on &lt;a href="https://docs.microsoft.com/en-us/azure/azure-monitor/logs/log-analytics-tutorial?WT.mc_id=AZ-MVP-5002677"&gt;Microsoft Docs&lt;/a&gt; if you're new to Azure Log Analytics)&lt;/em&gt;&lt;/p&gt;
&lt;h3 id="top-5-used-packages"&gt;Top 5 used packages&lt;/h3&gt;
&lt;p&gt;The below query counts unique repositories group by package id and returns the five with the highest package count.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-fsharp"&gt;NuGetReport_CL
| where TimeGenerated &amp;gt;= ago(2d)
| summarize Count = dcount(buildSCM_s) by packageId_s
| order by Count desc, packageId_s asc
| take 5
&lt;/code&gt;&lt;/pre&gt;
&lt;br /&gt;
&lt;h3 id="top-5-used-packages-by-last-report-per-repository"&gt;Top 5 used packages by last report per repository&lt;/h3&gt;
&lt;p&gt;When querying you in general just want the latest set of data per repository, to solve this you can use the fact that each report execution has a unique session-id, and each log has a date/time when ingested.&lt;/p&gt;
&lt;p&gt;By fetching the last session-id we can get a more correct picture of package usage, as a package could have been removed/updated between reports. There are several ways to solve this, in the example below, we use the &lt;a href="https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/arg-max-aggfunction?WT.mc_id=AZ-MVP-5002677"&gt;arg_max&lt;/a&gt; aggregation function to get the session id based on the highest time generated grouped by repository name using the &lt;a href="https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/summarizeoperator?WT.mc_id=AZ-MVP-5002677"&gt;summarize&lt;/a&gt; operator.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-fsharp"&gt;NuGetReport_CL
| where TimeGenerated &amp;gt;= ago(2d)
| summarize arg_max(TimeGenerated, sessionId_g) by buildSCM_s
| join NuGetReport_CL on $left.sessionId_g == $right.sessionId_g
| summarize Count = dcount(buildSCM_s) by packageId_s
| order by Count desc, packageId_s asc
| take 5
&lt;/code&gt;&lt;/pre&gt;
&lt;br /&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/03/20/top5packagesquery.gif?sp=r&amp;amp;st=2021-03-19T11:32:00Z&amp;amp;se=2031-03-21T11:32:00Z&amp;amp;sv=2020-02-10&amp;amp;sr=b&amp;amp;sig=hMWNA6rshw2MfQ8WmufiaLcJ%2FaektrDjnhsu6qotrSo%3D" alt="Query Top 5 used packages by last report per repository" /&gt;&lt;/p&gt;
&lt;br /&gt;
&lt;h3 id="custom-log-nugetreport_cl-columns"&gt;Custom log NuGetReport_CL columns&lt;/h3&gt;
&lt;p&gt;Above were just a couple of examples of NuGet package references queries, but there are almost endless possibilities, and the columns to your disposable are&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;TimeGenerated&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Date/time &lt;strong&gt;UTC&lt;/strong&gt; data ingested&lt;/td&gt;
&lt;td&gt;&lt;code&gt;2021-03-18T15:07:06.46Z&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Computer&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Machine name log generated on&lt;/td&gt;
&lt;td&gt;&lt;code&gt;fv-az68-89&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;buildVersion_s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Value passed using &lt;code&gt;--buildversion&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;2021.03.18.18138&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;buildNo_s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Build number from build provider&lt;/td&gt;
&lt;td&gt;&lt;code&gt;664953123-3544&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;timestamp_t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Date/time &lt;strong&gt;UTC&lt;/strong&gt; data reported&lt;/td&gt;
&lt;td&gt;&lt;code&gt;2021-03-18T15:07:04.798Z&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;platformFamily_s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Operating system reported from&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Linux&lt;/code&gt;, &lt;code&gt;OSX&lt;/code&gt;, &lt;code&gt;Window&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;buildSCM_s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Source control reference&lt;/td&gt;
&lt;td&gt;&lt;code&gt;devlead/DPI&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;buildProvider_s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Build provider&lt;/td&gt;
&lt;td&gt;&lt;code&gt;GitHubActions&lt;/code&gt;, &lt;code&gt;AppVeyor&lt;/code&gt;, &lt;code&gt;AzurePipelinesHosted&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;source_s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Relative file path where references found&lt;/td&gt;
&lt;td&gt;&lt;code&gt;src/DPI/DPI.csproj&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;sourceType_s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Type of source file&lt;/td&gt;
&lt;td&gt;&lt;code&gt;CSProj&lt;/code&gt;, &lt;code&gt;Cake&lt;/code&gt;, &lt;code&gt;DotNetToolsManifest&lt;/code&gt;, &lt;code&gt;PackagesConfig&lt;/code&gt;, &lt;code&gt;ProjectAssets&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;packageId_s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;NuGet package id&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Cake.Bridge.DependencyInjection&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;version_s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;NuGet package version&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0.5.0&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;sessionId_g&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Unique correlation id for each report&lt;/td&gt;
&lt;td&gt;&lt;code&gt;b85f687f-9e34-43c6-8a45-f8b803b373ce&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;targetFramework_s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Package .NET target framework&lt;/td&gt;
&lt;td&gt;&lt;code&gt;net5.0&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;br /&gt;
&lt;h2 id="future"&gt;Future&lt;/h2&gt;
&lt;p&gt;This project was initially done for my own fun and profit, and during that process realized that this can be really useful.&lt;/p&gt;
&lt;p&gt;There's currently no set roadmap, but there are a few things on my radar that I would like to add support for:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Docker images&lt;/li&gt;
&lt;li&gt;NPM packages&lt;/li&gt;
&lt;li&gt;More .NET project types&lt;/li&gt;
&lt;li&gt;SDK versions&lt;/li&gt;
&lt;li&gt;Reporting to more services and formats&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And that I would happily take contributions in form of PRs and issues, the code is open-source and available on GitHub at &lt;a href="https://github.com/devlead/DPI"&gt;github.com/devlead/DPI&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;dpi&lt;/code&gt; is starting to become a really versatile tool, it's a bit abstract to explain, and I've struggled with that a bit with this blog post, but hopefully, I've at least somewhat painted a picture of what's possible, and what problems it can help to solve. I've personally found the process of ingesting &amp;quot;raw&amp;quot; data and then querying both powerful and inspirational, some answers have led to going down rabbit holes of answering new questions.&lt;/p&gt;
&lt;p&gt;Please take it for a spin and if you have any questions, suggestions, or even opinions please feel free to reach out.&lt;/p&gt;
&lt;h2 id="thanks"&gt;Thanks&lt;/h2&gt;
&lt;p&gt;This tool was made possible thanks to a couple of excellent open source projects, special thanks go out to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/spectresystems/spectre.console"&gt;Spectre.Console&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/agc93/spectre.cli.extensions.dependencyinjection"&gt;Spectre.Cli.Extensions.DependencyInjection&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/reactive"&gt;Reactive Extensions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/cake-build/cake/"&gt;Cake&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/devlead/Cake.Bridge.DependencyInjection"&gt;Cake.Bridge.DependencyInjection&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>A DevOps tool to inspect dependencies and report to Azure Log Analytics</summary>
	</entry>
</feed>