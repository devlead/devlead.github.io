<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<id>https://www.devlead.se/</id>
	<title />
	<link rel="self" href="https://www.devlead.se/" />
	<rights>© Mattias Karlsson 2023</rights>
	<updated>2023-11-27T20:29:22Z</updated>
	<logo>https://cdn.devlead.se/clipimg-vscode/2021/01/11/1f2af322-a19f-753d-bd3e-00118dc674f1.png?sv=2019-12-12&amp;st=2021-01-10T15%253A16%253A48Z&amp;se=2031-01-11T15%253A16%253A48Z&amp;sr=b&amp;sp=r&amp;sig=RYHdZjTvO%252Fw0tUGsgnIiGJRhTiQQPHnEsSKtnV14Yoc%253D</logo>
	<entry>
		<id>https://www.devlead.se/posts/2023/2023-11-27-introducing-bri</id>
		<title>Introducing BRI</title>
		<author>
			<name>devlead</name>
		</author>
		<link href="https://www.devlead.se/posts/2023/2023-11-27-introducing-bri" />
		<link rel="enclosure" type="image" href="https://cdn.devlead.se/clipimg-vscode/2022/11/27/9a2ae7d59ab04134b044699dfa437e61.jpg?sv=2021-10-04&amp;st=2023-11-27T19%253A40%253A55Z&amp;se=2031-11-28T19%253A40%253A00Z&amp;sr=b&amp;sp=r&amp;sig=0KWUea7yaM5YorSAtmNaMUCHPjJRaMiqif95E1o%252BW%252Bo%253D" />
		<updated>2023-11-27T00:00:00Z</updated>
		<content>&lt;p&gt;Are you looking for a way to document your Azure &lt;a href="https://learn.microsoft.com/en-us/azure/azure-resource-manager/bicep/overview?tabs=bicep"&gt;Bicep&lt;/a&gt; &lt;a href="https://learn.microsoft.com/en-us/azure/azure-resource-manager/bicep/modules"&gt;modules&lt;/a&gt; in a simple and elegant way? If so, you might want to check out BRI, a .NET tool that I created to help you with that.&lt;/p&gt;
&lt;h2 id="what-is-bri"&gt;What is BRI?&lt;/h2&gt;
&lt;p&gt;BRI stands for Bicep registry inventory, and it does exactly what the name suggests: it scans a provided Azure Container Registry for any published Bicep modules and generates markdown files for each module version. These markdown files contain information about the module's input parameters, output values, and example usage. You can then use these files with any static site generator that supports markdown, such as &lt;a href="https://statiq.dev/"&gt;Statiq&lt;/a&gt;, to create a beautiful documentation site for your modules.&lt;/p&gt;
&lt;h2 id="how-to-use-bri"&gt;How to use BRI?&lt;/h2&gt;
&lt;p&gt;BRI is very easy to use. You just need to install it from &lt;a href="https://www.nuget.org/packages/bri"&gt;NuGet.org&lt;/a&gt; using the &lt;a href="https://get.dot.net/"&gt;.NET SDK&lt;/a&gt; &lt;a href="https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-tool-install"&gt;tool install command&lt;/a&gt;. It supports both .NET 7 and .NET 8, and you can install it globally or locally. For example, to install it globally, you can run:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet tool install --global BRI
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or, to install it locally (tool manifest), you can run:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet tool install --local BRI
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once installed, you can run BRI by typing (&lt;code&gt;dotnet bri&lt;/code&gt; if installed locally):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;bri inventory &amp;lt;container registry name&amp;gt; &amp;lt;output path&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For example, to scan the container registry named myregistry.azurecr.io and generate markdown files in the ./output/path folder, you can run:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;bri inventory myregistry.azurecr.io ./output/path
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="example"&gt;Example&lt;/h2&gt;
&lt;p&gt;You can see an example of the output that BRI generates at &lt;a href="https://www.devlead.se/bri/britool.azurecr.io/Bicep/modules/bri/4.0.0.0#overview"&gt;www.devlead.se/bri/&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.devlead.se/bri/britool.azurecr.io/Bicep/modules/bri/4.0.0.0#overview"&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2022/11/27/00ee924d-9de2-4b2b-90cc-1b5a8bcfb696_small.jpg?sv=2021-10-04&amp;amp;st=2023-11-27T19%3A39%3A50Z&amp;amp;se=2031-11-28T19%3A39%3A00Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=oree1I2Ia%2BqTdwXxZ1teSRHTf9iPODDLjjp5HvUGVsA%3D" alt="example" /&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="authentication"&gt;Authentication&lt;/h2&gt;
&lt;p&gt;By default, it'll try to authenticate using the &lt;a href="https://learn.microsoft.com/en-us/dotnet/api/azure.identity.defaultazurecredential?view=azure-dotnet"&gt;DefaultAzureCredential&lt;/a&gt; which tries to authorize in the following order based on your environment.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/azure.identity.environmentcredential?view=azure-dotnet"&gt;EnvironmentCredential&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/azure.identity.workloadidentitycredential?view=azure-dotnet"&gt;WorkloadIdentityCredential&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/azure.identity.managedidentitycredential?view=azure-dotnet"&gt;ManagedIdentityCredential&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/azure.identity.sharedtokencachecredential?view=azure-dotnet"&gt;SharedTokenCacheCredential&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/azure.identity.visualstudiocredential?view=azure-dotnet"&gt;VisualStudioCredential&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/azure.identity.visualstudiocodecredential?view=azure-dotnet"&gt;VisualStudioCodeCredential&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/azure.identity.azureclicredential?view=azure-dotnet"&gt;AzureCliCredential&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/azure.identity.azurepowershellcredential?view=azure-dotnet"&gt;AzurePowerShellCredential&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/azure.identity.azuredeveloperclicredential?view=azure-dotnet"&gt;AzureDeveloperCliCredential&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/azure.identity.interactivebrowsercredential?view=azure-dotnet"&gt;InteractiveBrowserCredential&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If running in a DevOps pipeline recommended way is to use a managed/workload identity, or create an Entra ID &lt;a href="https://learn.microsoft.com/en-us/entra/identity-platform/app-objects-and-service-principals?tabs=browser"&gt;service principal&lt;/a&gt; and set the following environment variables fetched from pipeline secrets&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;AZURE_TENANT_ID&lt;/code&gt; to its tenant ID&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AZURE_CLIENT_ID&lt;/code&gt; to its client ID&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AZURE_CLIENT_SECRET&lt;/code&gt; to its secret.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AZURE_AUTHORITY_HOST&lt;/code&gt; to &lt;code&gt;https://login.microsoftonline.com/&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="where-to-find-bri"&gt;Where to find BRI?&lt;/h2&gt;
&lt;p&gt;BRI is open source and licensed under the MIT license, so you can use it freely and modify it as you wish. You can find the source code on &lt;a href="https://github.com/devlead/BRI"&gt;GitHub&lt;/a&gt; and the NuGet package at &lt;a href="https://www.nuget.org/packages/bri"&gt;NuGet.org&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="feedback-and-suggestions"&gt;Feedback and suggestions&lt;/h2&gt;
&lt;p&gt;I hope you find BRI useful and that it helps you with your Bicep module development. If you have any feedback or suggestions, please feel free to open an issue or a pull request on GitHub. Happy coding!&lt;/p&gt;
</content>
		<summary>A DevOps tool to document Bicep modules in a Azure container registry</summary>
	</entry>
	<entry>
		<id>https://www.devlead.se/posts/2021/2021-09-23-joining-the-net-foundation-board-of-directors</id>
		<title>Joining the .NET Foundation Board of Directors</title>
		<author>
			<name>devlead</name>
		</author>
		<link href="https://www.devlead.se/posts/2021/2021-09-23-joining-the-net-foundation-board-of-directors" />
		<link rel="enclosure" type="image" href="https://cdn.devlead.se/clipimg-vscode/2021/09/23/468b4b6e-3ecd-c723-3323-8ffce93ac433.png?sv=2019-12-12&amp;st=2021-09-22T14%253A02%253A54Z&amp;se=2031-09-23T14%253A02%253A54Z&amp;sr=b&amp;sp=r&amp;sig=kN9k556DBbpI5pYPbI2tLDpXGiLFIJRsBsZ07Pf1LEc%253D" />
		<updated>2021-09-23T00:00:00Z</updated>
		<content>&lt;p&gt;Yesterday the .NET Foundation &lt;a href="https://dotnetfoundation.org/blog/2021/09/22/net-foundation-election-results-2021"&gt;announced&lt;/a&gt; the results from the 2021 Board of Directors Election. An election where the Foundation's members choose who they want to represent them on the board and this election set out to fill four out of seven seats.&lt;/p&gt;
&lt;p&gt;And I'm deeply honored to announce that I have this election been elected along with&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://dotnetfoundation.org/about/election/campaign-2021/frank-arkhurst-odoom"&gt;Frank Odoom&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://dotnetfoundation.org/about/election/campaign-2021/javier-lozano"&gt;Javier Lozano&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://dotnetfoundation.org/about/election/campaign-2021/rob-prouse"&gt;Rob Prouse&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="the-new-board-of-directors"&gt;The new Board of Directors&lt;/h2&gt;
&lt;p&gt;This means that as a result of the election the board will have the following members&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bill Wagner&lt;/li&gt;
&lt;li&gt;Frank Odoom&lt;/li&gt;
&lt;li&gt;Javier Lozano&lt;/li&gt;
&lt;li&gt;Mattias Karlsson&lt;/li&gt;
&lt;li&gt;Rich Lander&lt;/li&gt;
&lt;li&gt;Rob Prouse&lt;/li&gt;
&lt;li&gt;Shawn Wildermuth&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="changes-to-the-board-of-directors"&gt;Changes to the Board of Directors&lt;/h2&gt;
&lt;p&gt;Javier Lozano was re-elected, so leaving the board are&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Beth Massi&lt;/li&gt;
&lt;li&gt;Jeff Strauss&lt;/li&gt;
&lt;li&gt;Layla Porter&lt;/li&gt;
&lt;li&gt;Rodney Littles II&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Beth, Jeff, Layla, Rodney thanks you for your hard work! ❤️&lt;/p&gt;
&lt;h2 id="personal-reflections"&gt;Personal reflections&lt;/h2&gt;
&lt;p&gt;I'm truly humbled by the confidence placed in me by the Foundation members, so thank you!❤️&lt;/p&gt;
&lt;p&gt;I just got the news at the same time as the rest of the world, so I'm far from onboarded yet, and honestly don't have a 100% clear picture of what to expect and what's expected of me.&lt;/p&gt;
&lt;p&gt;But at the same time, I know too well how much hard and frustrating work it can be from years of experience participating in various boards, non-profits, communities, and open source projects. And I've got huge respect for the tasks and challenges at hand. The board speaks in one voice but consists of several voices, yours included.
There are several challenges we face, some issues may be small, others unacceptable which clearly need to be addressed, key problem areas in my mind are:&lt;/p&gt;
&lt;h3 id="diversity"&gt;Diversity&lt;/h3&gt;
&lt;p&gt;We need for the  .NET community to be welcoming safe, inclusive, and representative for current and new participants. And it's clear there's room for improvement here.
This includes the Board of Directors, which in my opinion isn't representative - so here we will need your, members, committees, and the community help to hold us accountable and provide us honest constructive feedback. We can be good allies and champions, even if we're not serving in any official capacity. And truly hope we'll have a more representative board post next election.&lt;/p&gt;
&lt;h3 id="sustainability"&gt;Sustainability&lt;/h3&gt;
&lt;p&gt;Sustainability isn't just about adding members, projects, and responsibilities, it's also what happens after you've joined or promises have been made. It's not sustainable if members, maintainers, and community leaders burn out, feel unwelcome or unheard. We can't grow if we at the same time have a churn of people and projects. Don't set things in motion you don't have a plan for how to maintain it - or clearly scope that it's time-limited.&lt;/p&gt;
&lt;h3 id="transparency"&gt;Transparency&lt;/h3&gt;
&lt;p&gt;For me, this is hugely centered around communication, only promise what you can deliver on, clearly communicate what can be expected and when to expect it. If you're unsure, clarify. If you can't communicate yet - communicate that - silence isn't respectful and just fuels misinformation.&lt;/p&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Thanks for the confidence! this will be an interesting journey, and truly hope I can represent you well. I will need some time to be the &amp;quot;new person&amp;quot; - hear people out, ask stupid questions, inventory which tools are at hand, and so on.&lt;/p&gt;
</content>
		<summary>A reflection on the results from the 2021 Board of Directors Election</summary>
	</entry>
	<entry>
		<id>https://www.devlead.se/posts/2021/2021-04-11-devlead-statiq-part3-includecode</id>
		<title>Devlead.Statiq - Part 3 - IncludeCode 🤺</title>
		<author>
			<name>devlead</name>
		</author>
		<link href="https://www.devlead.se/posts/2021/2021-04-11-devlead-statiq-part3-includecode" />
		<link rel="enclosure" type="image" href="https://cdn.devlead.se/clipimg-vscode/2021/04/08/985368ff-3b5e-5079-00b1-2d01c433f6b8.png?sv=2019-12-12&amp;st=2021-04-07T21%253A28%253A53Z&amp;se=2031-04-08T21%253A28%253A53Z&amp;sr=b&amp;sp=r&amp;sig=yJSMzQzEuAd%252B1IyVh9Hsn%252FBBJE4iLet9Ymg6nOqFmCA%253D" />
		<updated>2021-04-11T00:00:00Z</updated>
		<content>&lt;p&gt;So I'm lazy... when doing a blog post, or documentation I don't want to repeat my self, and a prime example of that is when documenting Statiq features I found my self to want to both display both the "source" and the "result" without having to type the same thing twice nor update in multiple places and that's why I created the &lt;code&gt;IncludeCode&lt;/code&gt; Shortcode and in this last of the three-part introductory blog post series about the NuGet package &lt;a href="https://www.nuget.org/packages/Devlead.Statiq"&gt;Devlead.Statiq&lt;/a&gt; I'll tell you all about it.&lt;/p&gt;
&lt;h2 id="includecode-shortcode"&gt;IncludeCode Shortcode&lt;/h2&gt;
&lt;p&gt;Code include shortcode - A Statiq &lt;a href="https://statiq.dev/framework/content/shortcodes"&gt;shortcode&lt;/a&gt; enables you fetch an external file into a markdown code fence block.&lt;/p&gt;
&lt;p&gt;Statiq comes with a built in &lt;code&gt;Include&lt;/code&gt; shortcode, which will just merge in the source of another document into the document utilizing the shortcode. This is really handy as it'll for example lets you edit content in one place, but you can use it in multiple places keeping things dry.&lt;/p&gt;
&lt;p&gt;The issue and feature with &lt;code&gt;Include&lt;/code&gt; is that it'll be executed as part of your Statiq App pipeline, any code in it will be rendered. Which might not be what you want for a code sample. So I created the &lt;code&gt;IncludeCode&lt;/code&gt; shortcode which will process and include the external document within a markdown code fence.&lt;/p&gt;
&lt;h3 id="example-usage"&gt;Example usage&lt;/h3&gt;
&lt;!--?# IncludeCode "./../includes/posts/2021/devlead-statiq/includecode/includecode.md" /?--&gt;
&lt;h3 id="result"&gt;Result&lt;/h3&gt;
&lt;!--?# Include "./../includes/posts/2021/devlead-statiq/includecode/includecode.md" /?--&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;IncludeCode&lt;/code&gt; shortcode is a small addition, but it keeps my content DRY which I've learned to really appreciate as it not only reduces typing, but also reduces risk of inconsistencies and errors.&lt;/p&gt;
&lt;h2 id="resources"&gt;Resources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Statiq
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/statiqdev"&gt;GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://statiq.dev/"&gt;Documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Devlead.Statiq
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/devlead/Devlead.Statiq"&gt;GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.nuget.org/packages/Devlead.Statiq/"&gt;NuGet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.devlead.se/posts/2021/2021-04-09-devlead-statiq-part1-tabs"&gt;Part 1 - Tabs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.devlead.se/posts/2021/2021-04-10-devlead-statiq-part2-theme-from-uri"&gt;Part 2 - Theme from external web resource&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.devlead.se/posts/2021/2021-04-11-devlead-statiq-part3-includecode"&gt;Part 3 - IncludeCode 🤺&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>An .NET assembly extending the static site generator Statiq with new core features</summary>
	</entry>
	<entry>
		<id>https://www.devlead.se/posts/2021/2021-04-10-devlead-statiq-part2-theme-from-uri</id>
		<title>Devlead.Statiq - Part 2 - Theme from external web resource</title>
		<author>
			<name>devlead</name>
		</author>
		<link href="https://www.devlead.se/posts/2021/2021-04-10-devlead-statiq-part2-theme-from-uri" />
		<link rel="enclosure" type="image" href="https://cdn.devlead.se/clipimg-vscode/2021/04/08/04e3408e-5295-3d37-0421-11c3ec60a691.png?sv=2019-12-12&amp;st=2021-04-07T20%253A30%253A55Z&amp;se=2031-04-08T20%253A30%253A55Z&amp;sr=b&amp;sp=r&amp;sig=VI8xA0tYLfkNIsS%252FQx%252B9HDbDPU3n1TckpRJFflxg4sg%253D" />
		<updated>2021-04-10T00:00:00Z</updated>
		<content>&lt;p&gt;Sometimes you just want things your way, in this second part of the three-part introductory blog post series about the NuGet package &lt;a href="https://www.nuget.org/packages/Devlead.Statiq"&gt;Devlead.Statiq&lt;/a&gt;, I'll go through how it can enable having your Statiq web theme reside as a common external web resource.&lt;/p&gt;
&lt;h2 id="the-problem"&gt;The problem&lt;/h2&gt;
&lt;p&gt;Themes in Statiq are essentially a folder alongside your &lt;code&gt;input&lt;/code&gt; folder. An example of such a theme is &lt;a href="https://github.com/statiqdev/CleanBlog"&gt;statiqdev/CleanBlog&lt;/a&gt;, the official recommended way to use it as a GIT sub-module like below&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git submodule add https://github.com/statiqdev/CleanBlog.git theme
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But I wanted a way to just clone and build without the hassle of sub-modules, but I also didn't want to just "copy-and-paste" the theme. I still wanted to with ease take the benefits of any updates to the upstream repository.&lt;/p&gt;
&lt;h2 id="the-solution"&gt;The solution&lt;/h2&gt;
&lt;p&gt;My solution ended up to extend Statiq so I could just configure the theme to a specific external uri, pointing to a web resource containing a zip archive of that theme, and Statiq would then transparently download, extract and cache that theme as the site was generated. Changing the uri would invalidate the cache and fetch the theme again.&lt;/p&gt;
&lt;p&gt;Fortunately, GitHub provides the functionality to serve any commit/tag/release as a zip archive using the &lt;code&gt;https://github.com/{owner}/{repo}/archive/{reference}&lt;/code&gt; syntax, i.e. &lt;code&gt;https://github.com/statiqdev/CleanBlog/archive/ceb5055f3d0f7a330708494ed21eb469cde62ce2.zip&lt;/code&gt;, making it really easy to obtain a specific immutable version of an upstream theme.&lt;/p&gt;
&lt;p&gt;I then "gitignored" my &lt;code&gt;theme&lt;/code&gt; folder - so it would never be added to the site's repository. I made sure any site-specific modifications only existed within my Statiq content &lt;code&gt;input&lt;/code&gt; folder - ensuring new versions of the theme could be fetched without losing my tweaks to the theme.&lt;/p&gt;
&lt;h2 id="example-usage"&gt;Example usage&lt;/h2&gt;
&lt;p&gt;First of all in your Statiq App you need to add the &lt;a href="https://www.nuget.org/packages/Devlead.Statiq"&gt;Devlead.Statiq&lt;/a&gt; NuGet package to your Statiq web application.&lt;/p&gt;
&lt;p&gt;Then theme from uri support in Statiq is enabled like below by invoking the &lt;code&gt;AddThemeFromUri&lt;/code&gt; extension on the Statiq app &lt;a href="https://statiq.dev/framework/configuration/bootstrapper/"&gt;Bootstrapper&lt;/a&gt;, and as a parameter to it specifying the uri where the theme zip archive is located&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using System;
using Devlead.Statiq.Themes;
using Statiq.App;
using Statiq.Common;
using Statiq.Web;

await Bootstrapper
    .Factory
    .CreateDefault(args)
    .AddThemeFromUri(new Uri("https://github.com/statiqdev/CleanBlog/archive/ceb5055f3d0f7a330708494ed21eb469cde62ce2.zip"))
    .AddWeb()
    .RunAsync();

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;IMHO this results in a fairly clean way to reuse themes between sites and makes it easy to contribute to a site using this method - all the setup a contributor needs to be able to test/preview the site clone the repository and run the project.&lt;/p&gt;
&lt;h2 id="resources"&gt;Resources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Statiq
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/statiqdev"&gt;GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://statiq.dev/"&gt;Documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Devlead.Statiq
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/devlead/Devlead.Statiq"&gt;GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.nuget.org/packages/Devlead.Statiq/"&gt;NuGet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.devlead.se/posts/2021/2021-04-09-devlead-statiq-part1-tabs"&gt;Part 1 - Tabs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.devlead.se/posts/2021/2021-04-10-devlead-statiq-part2-theme-from-uri"&gt;Part 2 - Theme from external web resource&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.devlead.se/posts/2021/2021-04-11-devlead-statiq-part3-includecode"&gt;Part 3 - IncludeCode 🤺&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>An .NET assembly extending the static site generator Statiq with new core features</summary>
	</entry>
	<entry>
		<id>https://www.devlead.se/posts/2021/2021-04-09-devlead-statiq-part1-tabs</id>
		<title>Devlead.Statiq - Part 1 - Tabs</title>
		<author>
			<name>devlead</name>
		</author>
		<link href="https://www.devlead.se/posts/2021/2021-04-09-devlead-statiq-part1-tabs" />
		<link rel="enclosure" type="image" href="https://cdn.devlead.se/clipimg-vscode/2021/04/05/390eeb4b-ad66-7406-860f-44ed05918873.png?sv=2019-12-12&amp;st=2021-04-04T18%253A20%253A27Z&amp;se=2031-04-05T18%253A20%253A27Z&amp;sr=b&amp;sp=r&amp;sig=yLJRew2YKzfdLNObjcb3I6kkwfWiegYX%252FP68MwmoX3k%253D" />
		<updated>2021-04-09T00:00:00Z</updated>
		<content>&lt;p&gt;Earlier this year I blogged about that my &lt;a href="https://www.devlead.se/posts/2021/2021-01-11-blog-migrated-to-statiq"&gt;"Blog migrated to Statiq"&lt;/a&gt;, one advantage with &lt;a href="https://statiq.dev/"&gt;Statiq&lt;/a&gt; is that it's through .NET code really customizable and lets you adapt it fully to your needs. Code that can be packaged and distributed as a NuGet package, making it straightforward to share and reuse functionality between sites.&lt;br&gt; &lt;br&gt; In a three-part blog post series, I'll start going through the features of the NuGet package &lt;a href="https://www.nuget.org/packages/Devlead.Statiq"&gt;Devlead.Statiq&lt;/a&gt; created for my own Statiq based sites - but probably useful for others too, and this first part will be about the TabGroup Shortcode.&lt;/p&gt;
&lt;h2 id="tabgroup-shortcode"&gt;TabGroup Shortcode&lt;/h2&gt;
&lt;!--?# TabGroup ?--&gt;
&lt;!--?*
tabs:
  - name: Introduction
    content: |
      Statiq [shortcodes](https://statiq.dev/framework/content/shortcodes) are small but powerful macros that can generate content or add metadata to your documents.

      The `TabGroup` shortcode, is a CSS-only solution to simplify adding tabs in your Statiq input files.

      Why add tabs? Well with some content, a good example of that is code samples, tabs make it easier to group content together, keep things more focused and reduce user vertical scrolling.

      With the `TabGroup` shortcode tab content can be defined as either

      - Content - markdown defined directly in the shortcode content
      - Include - markdown fetched and processed from a external file
      - Code - fetch external file into markdown code fence

      the shortcode content is defined as `YAML`, you can within a single tab combine all variants (`content`, `include`, and `code`), and it'll render in the following order

      1. `content`
      1. `include`
      1. `code`

  - include: ./../includes/posts/2021/devlead-statiq/tabgroup/prerequisites.md

  - include: ./../includes/posts/2021/devlead-statiq/tabgroup/content.md

  - include: ./../includes/posts/2021/devlead-statiq/tabgroup/include.md

  - include: ./../includes/posts/2021/devlead-statiq/tabgroup/code.md

?--&gt;
&lt;!--?#/ TabGroup ?--&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;I'm really happy how flexible and versatile the &lt;code&gt;TabGroup&lt;/code&gt; shortcode ended up being, while still keeping my markdown files nice and tidy, abstracting away the complexity.&lt;/p&gt;
&lt;h2 id="resources"&gt;Resources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Statiq
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/statiqdev"&gt;GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://statiq.dev/"&gt;Documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Devlead.Statiq
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/devlead/Devlead.Statiq"&gt;GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.nuget.org/packages/Devlead.Statiq/"&gt;NuGet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.devlead.se/posts/2021/2021-04-09-devlead-statiq-part1-tabs"&gt;Part 1 - Tabs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.devlead.se/posts/2021/2021-04-10-devlead-statiq-part2-theme-from-uri"&gt;Part 2 - Theme from external web resource&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.devlead.se/posts/2021/2021-04-11-devlead-statiq-part3-includecode"&gt;Part 3 - IncludeCode 🤺&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>An .NET assembly extending the static site generator Statiq with new core features</summary>
	</entry>
	<entry>
		<id>https://www.devlead.se/posts/2021/2021-03-20-introducing-dpi</id>
		<title>Introducing DPI</title>
		<author>
			<name>devlead</name>
		</author>
		<link href="https://www.devlead.se/posts/2021/2021-03-20-introducing-dpi" />
		<link rel="enclosure" type="image" href="https://cdn.devlead.se/clipimg-vscode/2021/03/16/5e783ec1-b7cf-aaac-bf41-582e4110dfa9.png?sv=2019-12-12&amp;st=2021-03-15T19%253A51%253A42Z&amp;se=2031-03-16T19%253A51%253A42Z&amp;sr=b&amp;sp=r&amp;sig=0jvdk30dmb7ba7dKnLlfNMvY32nKHI1kqCxXzz3VhXo%253D" />
		<updated>2021-03-20T00:00:00Z</updated>
		<content>&lt;p&gt;When brought in as DevOps consultant or a new employee for that matter, one is often tasked with getting a clear picture of the current state of projects, how they work and fit together.&lt;br /&gt;&lt;br /&gt;
A big part of this initial and ongoing is to analyze and audit dependencies, which is why I've created &lt;code&gt;dpi&lt;/code&gt; a tool that both locally and as part of your DevOps pipeline can analyze your repository projects dependencies and report to Azure Log Analytics, console, and files.&lt;/p&gt;
&lt;h2 id="the-tools-initial-scope"&gt;The tool's initial scope&lt;/h2&gt;
&lt;p&gt;In this initial version, focus has been fairly complete support for C# .NET NuGet package dependencies, and the tool currently supports analyzing and reporting NuGet package dependencies for:&lt;/p&gt;
&lt;ul class="contains-task-list"&gt;
&lt;li class="task-list-item"&gt;&lt;input disabled="disabled" type="checkbox" checked="checked" /&gt; C# project files&lt;/li&gt;
&lt;li class="task-list-item"&gt;&lt;input disabled="disabled" type="checkbox" checked="checked" /&gt; MS Build Project assets&lt;/li&gt;
&lt;li class="task-list-item"&gt;&lt;input disabled="disabled" type="checkbox" checked="checked" /&gt; NuGet Package config files&lt;/li&gt;
&lt;li&gt;Cake script
&lt;ul class="contains-task-list"&gt;
&lt;li class="task-list-item"&gt;&lt;input disabled="disabled" type="checkbox" checked="checked" /&gt; Addins&lt;/li&gt;
&lt;li class="task-list-item"&gt;&lt;input disabled="disabled" type="checkbox" checked="checked" /&gt; Tools&lt;/li&gt;
&lt;li class="task-list-item"&gt;&lt;input disabled="disabled" type="checkbox" checked="checked" /&gt; Modules&lt;/li&gt;
&lt;li class="task-list-item"&gt;&lt;input disabled="disabled" type="checkbox" checked="checked" /&gt; Recipes&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="tool-value-proposition"&gt;Tool value proposition?&lt;/h2&gt;
&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/03/17/0f47c134-5029-94f4-7a4e-07d4cd5b5d77.png?sv=2019-12-12&amp;st=2021-03-16T20%3A08%3A30Z&amp;se=2031-03-17T20%3A08%3A30Z&amp;sr=b&amp;sp=r&amp;sig=ZXq2a0u1x0ows1MPnkzgCWtLMz8fjvJLXvGtyVeu0dE%3D" alt="KQL Collage" align="right" width="600" height="426" /&gt;
&lt;p&gt;Analyzing and reporting dependencies to a central place enables you to discover, correlate, and aggregate dependencies across multiple locations. &lt;code&gt;dpi&lt;/code&gt; reports its findings to an Azure Log Analytics workspace, which provides an efficient way to store and query large amounts of tabular data using &lt;a href="https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/?WT.mc_id=AZ-MVP-5002677"&gt;KQL - Kusto Query Language&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This enables you to quickly tackle several scenarios i.e&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Find which repositories have certain dependencies&lt;/li&gt;
&lt;li&gt;Identify which versions of dependencies used&lt;/li&gt;
&lt;li&gt;Most / least used dependencies&lt;/li&gt;
&lt;li&gt;If a dependency is used anywhere&lt;/li&gt;
&lt;li&gt;Follow dependency usage over time&lt;/li&gt;
&lt;li&gt;Only limited outbound/one-way http traffic with analytics data to one common endpoint&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h2 id="acquiring-the-tool"&gt;Acquiring the tool&lt;/h2&gt;
&lt;h3 id="requirements"&gt;Requirements&lt;/h3&gt;
&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/03/18/64b64f7a-9eaa-3753-71e5-781a58a6d188.png?sv=2019-12-12&amp;st=2021-03-17T17%3A08%3A25Z&amp;se=2031-03-18T17%3A08%3A25Z&amp;sr=b&amp;sp=r&amp;sig=1iNd2EAsow19wsG8M2Av69Y52BjqUpzKl13bXiQxZ%2FY%3D" alt="Azure Log Analytics Workspace Agents management" align="right" /&gt;
&lt;p&gt;&lt;code&gt;dpi&lt;/code&gt; is a .NET 5 Tool, so .NET 5 SDK is required to be installed - you can find the download and install the latest version of the .NET SDK from &lt;a href="https://get.dot.net/"&gt;get.dot.net&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The tool is published to and distributed via &lt;a href="https://www.nuget.org/packages/DPI/"&gt;NuGet.org&lt;/a&gt;, but you could also upload it to your internal NuGet feed and have your users and pipelines obtain it from there.&lt;/p&gt;
&lt;p&gt;To report you also need an Azure Log Analytics workspace, and the tool uses Workspace Id and Key (either primary or secondary, both work), you'll find those under &amp;quot;Agents management&amp;quot;&lt;/p&gt;
&lt;br /&gt;
&lt;h3 id="installing-globally"&gt;Installing globally&lt;/h3&gt;
&lt;p&gt;.NET Tools can be installed globally for the current user using the .NET SDK CLI&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet tool install --global DPI
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once installed the tool will be available anywhere for the current user as &lt;code&gt;dotnet tool run dpi&lt;/code&gt;, &lt;code&gt;dotnet dpi&lt;/code&gt;, or just &lt;code&gt;dpi&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id="installing-via-tool-manifest"&gt;Installing via Tool manifest&lt;/h3&gt;
&lt;p&gt;My preferred way to install and maintain a .NET tool is using a .NET local tool manifest file added to your repository, this means which tools are used and their specific versions is maintained within the repository.&lt;/p&gt;
&lt;p&gt;If you don't have a manifest in your repository already, the easiest way to create a new manifest is by using the .NET SDK CLI in your repo root.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet new tool-manifest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;then or if you already have a manifest you add the tool&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet tool install DPI
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the tool is now within the repository available as &lt;code&gt;dotnet tool run dpi&lt;/code&gt; or &lt;code&gt;dotnet dpi&lt;/code&gt;, then your pipelines and anyone cloning your repository can obtain all your specified tools with the same versions as you're using by executing&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet tool restore
&lt;/code&gt;&lt;/pre&gt;
&lt;br /&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;h3 id="nuget-analyze-command"&gt;NuGet Analyze command&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;dpi nuget [SourcePath] [NUGET OPTIONS] analyze [ANALYZE OPTIONS]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The NuGet analyze command will inventory the specified path recursively for known files containing references to NuGet packages and output its findings to the console, the current directory will be used if no path specified.&lt;/p&gt;
&lt;h4 id="example-analyzing-current-directory"&gt;Example analyzing current directory&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet dpi nuget analyze
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="example-analyzing-specific-directory"&gt;Example analyzing specific directory&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet dpi nuget ./path/to/folder analyze
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="nuget-report-command"&gt;NuGet Report command&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;dpi nuget [SourcePath] [NUGET OPTIONS] report [REPORT OPTIONS]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The NuGet report command will beyond analyze also report tools findings as a custom log to Azure Log Analytics.&lt;/p&gt;
&lt;h4 id="example-analyzing-and-reporting-current-directory"&gt;Example analyzing and reporting current directory&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet dpi nuget report --workspace &amp;lt;WORKSPACEID&amp;gt; --sharedkey &amp;lt;SHAREDKEY&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="example-analyzing-and-reporting-specific-directory"&gt;Example analyzing and reporting specific directory&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet dpi nuget ./path/to/folder report --workspace &amp;lt;WORKSPACEID&amp;gt; --sharedkey &amp;lt;SHAREDKEY&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Azure Log Analytics Workspace ID and Key can also be passed as environment variables &lt;code&gt;NuGetReportSettings_WorkspaceId&lt;/code&gt; and &lt;code&gt;NuGetReportSettings_SharedKey&lt;/code&gt;, which is the preferred way when passing secrets in a DevOps pipeline, the result of nuget analyze is reported to custom log &lt;code&gt;NuGetReport_CL&lt;/code&gt; in the specified workspace.&lt;/p&gt;
&lt;h3 id="console-output-formats"&gt;Console output formats&lt;/h3&gt;
&lt;p&gt;By using the &lt;code&gt;--output &amp;lt;FORMAT&amp;gt;&lt;/code&gt; option you can change the console output of the tools analyze result, currently, the tool supports the following formats&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JSON - output in a machine consumable JSON format&lt;/li&gt;
&lt;li&gt;TABLE - outputs a nicely formatted table format&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(You can use the &lt;code&gt;--file &amp;lt;FILEPATH&amp;gt;&lt;/code&gt; option to output to file instead of console)&lt;/p&gt;
&lt;h4 id="example-analyzing-and-outputting-as-json"&gt;Example analyzing and outputting as json&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet dpi nuget --output json analyze
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;[
  {
    &amp;quot;sessionId&amp;quot;: &amp;quot;b770baf0-8eb7-496f-aa19-770f36838689&amp;quot;,
    &amp;quot;buildProvider&amp;quot;: &amp;quot;Local&amp;quot;,
    &amp;quot;platformFamily&amp;quot;: &amp;quot;Windows&amp;quot;,
    &amp;quot;buildNo&amp;quot;: &amp;quot;202103181806&amp;quot;,
    &amp;quot;buildSCM&amp;quot;: &amp;quot;dpi&amp;quot;,
    &amp;quot;buildVersion&amp;quot;: null,
    &amp;quot;sourceType&amp;quot;: &amp;quot;CSProj&amp;quot;,
    &amp;quot;source&amp;quot;: &amp;quot;TestProj/TestProj.csproj&amp;quot;,
    &amp;quot;targetFramework&amp;quot;: &amp;quot;net5.0&amp;quot;,
    &amp;quot;packageId&amp;quot;: &amp;quot;Microsoft.Extensions.DependencyInjection&amp;quot;,
    &amp;quot;version&amp;quot;: &amp;quot;5.0.1&amp;quot;,
    &amp;quot;timestamp&amp;quot;: &amp;quot;2021-03-18T18:06:30.0178489+00:00&amp;quot;,
    &amp;quot;Computer&amp;quot;: &amp;quot;HAL&amp;quot;
  },
  {
    &amp;quot;sessionId&amp;quot;: &amp;quot;b770baf0-8eb7-496f-aa19-770f36838689&amp;quot;,
    &amp;quot;buildProvider&amp;quot;: &amp;quot;Local&amp;quot;,
    &amp;quot;platformFamily&amp;quot;: &amp;quot;Windows&amp;quot;,
    &amp;quot;buildNo&amp;quot;: &amp;quot;202103181806&amp;quot;,
    &amp;quot;buildSCM&amp;quot;: &amp;quot;dpi&amp;quot;,
    &amp;quot;buildVersion&amp;quot;: null,
    &amp;quot;sourceType&amp;quot;: &amp;quot;CSProj&amp;quot;,
    &amp;quot;source&amp;quot;: &amp;quot;TestProj/TestProj.csproj&amp;quot;,
    &amp;quot;targetFramework&amp;quot;: &amp;quot;net5.0&amp;quot;,
    &amp;quot;packageId&amp;quot;: &amp;quot;Cake.Core&amp;quot;,
    &amp;quot;version&amp;quot;: &amp;quot;1.1.0&amp;quot;,
    &amp;quot;timestamp&amp;quot;: &amp;quot;2021-03-18T18:06:30.0178489+00:00&amp;quot;,
    &amp;quot;Computer&amp;quot;: &amp;quot;HAL&amp;quot;
  }
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This means that you as an example in PowerShell could do something like the below script to get all versions of &lt;code&gt;YamlDotNet&lt;/code&gt; used.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;dotnet dpi nuget --output json analyze `
  | ConvertFrom-Json `
  | ForEach-Object { $_ } `
  | Where-Object { $_.packageId -eq 'YamlDotNet' } `
  | ForEach-Object version
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="example-analyzing-and-outputting-as-table"&gt;Example analyzing and outputting as table&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet dpi nuget --output table analyze
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/03/18/2465161d-a1c7-5401-b67e-8d84cf66911a.png?sv=2019-12-12&amp;amp;st=2021-03-17T18%3A21%3A33Z&amp;amp;se=2031-03-18T18%3A21%3A33Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=hsF2ReevVLx3mEaRmTumGikNQGuAJNGVD3FDB7zEOWM%3D" alt="Console example dpi table format" /&gt;&lt;/p&gt;
&lt;br /&gt;
&lt;h2 id="pipeline-examples"&gt;Pipeline examples&lt;/h2&gt;
&lt;p&gt;As &lt;code&gt;dpi&lt;/code&gt; is just a command-line tool, you can just use the same commands in your build pipeline as you use in your shell of choice locally.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;dotnet tool restore&lt;/code&gt; - Restore .NET Tools (i.e. download and install &lt;code&gt;dpi&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dotnet dpi &amp;lt;COMMAND&amp;gt; [COMMAND OPTIONS] &amp;lt;SUBCOMMAND&amp;gt; [SUB COMMAND OPTIONS]&lt;/code&gt; - Execute &lt;code&gt;dpi&lt;/code&gt; i.e. &lt;code&gt;nuget&lt;/code&gt; &lt;code&gt;analyze&lt;/code&gt; / &lt;code&gt;report&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The below pipeline examples you'll see two options not previously mentioned&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--silent&lt;/code&gt; - Silent removes all console log output except the &lt;code&gt;table&lt;/code&gt; (&lt;code&gt;json&lt;/code&gt; will bet &amp;quot;silent&amp;quot; by default so output can be parsed by another tool.)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--buildversion&lt;/code&gt; - Build version is an option to pass metadata unique to the workflow, in this case, the unique run number from GitHub Action workflow, but could i.e. be asserted version from a tool like GitVersion.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="github-action-workflow-example"&gt;GitHub Action workflow example&lt;/h3&gt;
&lt;p&gt;Below YAML example will&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Checks out code from the repository&lt;/li&gt;
&lt;li&gt;Installs .NET SDK based on &lt;a href="https://docs.microsoft.com/en-us/dotnet/core/tools/global-json?WT.mc_id=DT-MVP-5002677"&gt;global.json&lt;/a&gt; in repository&lt;/li&gt;
&lt;li&gt;Restore .NET Tools (i.e. &lt;code&gt;dpi&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Build project&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dpi&lt;/code&gt; Analyze if secrets &lt;strong&gt;aren't&lt;/strong&gt; available (i.e. a fork pull request)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dpi&lt;/code&gt; Report if secrets &lt;strong&gt;are&lt;/strong&gt; available (i.e. merged into &lt;code&gt;main&lt;/code&gt;)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;name: Build
on:
  pull_request:
  push:
    branches:
      - main

env:
  NuGetReportSettings_SharedKey: ${{ secrets.NUGETREPORTSETTINGS_SHAREDKEY }}
  NuGetReportSettings_WorkspaceId: ${{ secrets.NUGETREPORTSETTINGS_WORKSPACEID }}

jobs:
  build:
    runs-on: windows-latest
    steps:
      - name: Get the sources
        uses: actions/checkout&amp;#64;v2

      - name: Install .NET Core SDK
        uses: actions/setup-dotnet&amp;#64;v1

      - name: Restore .NET Tools
        run: dotnet tool restore

      - name: Build Project
        run: dotnet build

      - name: Run DPI Analyze
        if: ${{ env.NuGetReportSettings_SharedKey == null || env.NuGetReportSettings_WorkspaceId == null }}
        shell: bash
        run: dotnet dpi nuget --silent --output table analyze --buildversion $GITHUB_RUN_NUMBER

      - name: Run DPI Report
        if: ${{ env.NuGetReportSettings_SharedKey != null &amp;amp;&amp;amp; env.NuGetReportSettings_WorkspaceId != null }}
        shell: bash
        run: dotnet dpi nuget --silent --output table report --buildversion $GITHUB_RUN_NUMBER
&lt;/code&gt;&lt;/pre&gt;
&lt;br /&gt;
&lt;h3 id="azure-devops-pipelines-example"&gt;Azure DevOps Pipelines example&lt;/h3&gt;
&lt;p&gt;Below YAML example will&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Checks out code from the repository&lt;/li&gt;
&lt;li&gt;Installs .NET SDK based on &lt;a href="https://docs.microsoft.com/en-us/dotnet/core/tools/global-json?WT.mc_id=DT-MVP-5002677"&gt;global.json&lt;/a&gt; in the repository&lt;/li&gt;
&lt;li&gt;Restore .NET Tools (i.e. &lt;code&gt;dpi&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Build project&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dpi&lt;/code&gt; Analyze if it's a pull request&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dpi&lt;/code&gt; Report if executing in the &lt;code&gt;main&lt;/code&gt; branch&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;name: $(Year:yyyy).$(Month).$(DayOfMonth)$(Rev:.r)
trigger:
- main

pool:
  vmImage: 'windows-latest'

steps:
- task: UseDotNet&amp;#64;2
  displayName: 'Install .NET Core SDK'
  inputs:
    packageType: sdk
    useGlobalJson: true

- script: dotnet tool restore
  displayName: 'Restore .NET Tools'

- script: dotnet build src
  displayName: 'Build Project'

- script: dotnet dpi nuget --silent --output table analyze --buildversion &amp;quot;$(Build.BuildNumber)&amp;quot;
  displayName: Run DPI Analyze
  condition: eq(variables['Build.Reason'], 'PullRequest')

- script: dotnet dpi nuget --silent --output table report --buildversion &amp;quot;$(Build.BuildNumber)&amp;quot;
  displayName: Run DPI Report
  env:
    NuGetReportSettings_SharedKey: $(NUGETREPORTSETTINGS_SHAREDKEY)
    NuGetReportSettings_WorkspaceId: $(NUGETREPORTSETTINGS_WORKSPACEID)
  condition: eq(variables['Build.SourceBranch'], 'refs/heads/main')
&lt;/code&gt;&lt;/pre&gt;
&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/03/19/659e0331-59b9-a7b6-1a72-81c04208beaa.png?sv=2019-12-12&amp;st=2021-03-18T12%3A51%3A01Z&amp;se=2031-03-19T12%3A51%3A01Z&amp;sr=b&amp;sp=r&amp;sig=zEkSEyMfWQ5u4lJLxrPQHgooMxD10VmDNijiwnGkax0%3D" alt="Azure Pipelines Secrets" align="right" /&gt;
&lt;br /&gt;
&lt;p&gt;In the above example, the Azure Log Analytics Workspace Key and Id are passed as environment variables&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NuGetReportSettings_SharedKey&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NuGetReportSettings_WorkspaceId&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;which are populated from pipeline secret variables&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NUGETREPORTSETTINGS_SHAREDKEY&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NUGETREPORTSETTINGS_WORKSPACEID&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Pipeline variables are administrated under your Pipeline details -&amp;gt; Edit -&amp;gt; Variables, they're made secrets by checking the &amp;quot;Keep this value secret&amp;quot; checkbox.&lt;/p&gt;
&lt;p&gt;Secrets need to be explicitly defined in YAML to be accessible from tasks.&lt;/p&gt;
&lt;br /&gt;
&lt;h3 id="cake-build-examples"&gt;Cake build examples&lt;/h3&gt;
&lt;p&gt;There's not yet a Cake addin or built-in support for &lt;code&gt;dpi&lt;/code&gt;, but still, it's fairly straightforward to use &lt;code&gt;dpi&lt;/code&gt; from a Cake script.&lt;/p&gt;
&lt;h4 id="example-cake-script-dpi-installed-globally-via.net-tool-manifest"&gt;Example Cake script DPI installed globally / via .NET tool manifest&lt;/h4&gt;
&lt;p&gt;The Cake script below will&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Setup context
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Version&lt;/code&gt; - Date based here but normally fetched from build provider or asserted from a tool (&lt;em&gt;i.e. GitVersion&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Analyze&lt;/code&gt; - flag for if &lt;code&gt;analyze&lt;/code&gt; or &lt;code&gt;report&lt;/code&gt; based on presence of environment variables&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Build project&lt;/li&gt;
&lt;li&gt;Analyze or Report based on context &lt;code&gt;Analyze&lt;/code&gt; flag&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public record BuildData(string Version, bool Analyze);

Setup(
  static context =&amp;gt; new BuildData(
    Version: FormattableString.Invariant(
                $&amp;quot;{DateTime.UtcNow:yyyy.M.d}&amp;quot;
              ),
    Analyze: new[] {
              &amp;quot;NuGetReportSettings_SharedKey&amp;quot;,
              &amp;quot;NuGetReportSettings_WorkspaceId&amp;quot;
            }
            .Select(key =&amp;gt; context.EnvironmentVariable(key))
            .Where(string.IsNullOrWhiteSpace)
            .Any()
  )
);

Task(&amp;quot;Build&amp;quot;)
    .Does&amp;lt;BuildData&amp;gt;(
        static (context, data) =&amp;gt; context.DotNetCoreBuild(
          &amp;quot;src&amp;quot;,
          new DotNetCoreBuildSettings {
            MSBuildSettings = new DotNetCoreMSBuildSettings()
              .WithProperty(&amp;quot;Version&amp;quot;, data.Version)
          }
    )
  );

Task(&amp;quot;DPI&amp;quot;)
  .IsDependentOn(&amp;quot;Build&amp;quot;)
  .Does&amp;lt;BuildData&amp;gt;(
      static (context, data) =&amp;gt; context.DotNetCoreTool(
        &amp;quot;dpi&amp;quot;,
        new DotNetCoreToolSettings {
            ArgumentCustomization = args =&amp;gt; args
                                              .Append(&amp;quot;nuget&amp;quot;)
                                              .Append(&amp;quot;--silent&amp;quot;)
                                              .AppendSwitchQuoted(&amp;quot;--output&amp;quot;, &amp;quot;table&amp;quot;)
                                              .Append(data.Analyze ? &amp;quot;analyze&amp;quot; : &amp;quot;report&amp;quot;)
                                              .AppendSwitchQuoted(&amp;quot;--buildversion&amp;quot;, data.Version)
        }
      )
  );

Task(&amp;quot;Default&amp;quot;)
  .IsDependentOn(&amp;quot;DPI&amp;quot;);

RunTarget(Argument(&amp;quot;target&amp;quot;, &amp;quot;Default&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="example-self-contained-cake-script"&gt;Example Self-contained Cake script&lt;/h4&gt;
&lt;p&gt;The Cake script below will&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Install the specified version of &lt;code&gt;dpi&lt;/code&gt; into Cake tool directory from NuGet&lt;/li&gt;
&lt;li&gt;Setup context
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Version&lt;/code&gt; - Date based here but normally fetched from build provider or asserted from a tool (&lt;em&gt;i.e. GitVersion&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Analyze&lt;/code&gt; - flag for if &lt;code&gt;analyze&lt;/code&gt; or &lt;code&gt;report&lt;/code&gt; based on presence of environment variables&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Build project&lt;/li&gt;
&lt;li&gt;Analyze or Report based on context &lt;code&gt;Analyze&lt;/code&gt; flag&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;#tool dotnet:?package=DPI&amp;amp;version=2021.3.16.28

public record BuildData(string Version, bool Analyze);

Setup(
  static context =&amp;gt; new BuildData(
    Version: FormattableString.Invariant(
                $&amp;quot;{DateTime.UtcNow:yyyy.M.d}&amp;quot;
              ),
    Analyze: new[] {
              &amp;quot;NuGetReportSettings_SharedKey&amp;quot;,
              &amp;quot;NuGetReportSettings_WorkspaceId&amp;quot;
            }
            .Select(key =&amp;gt; context.EnvironmentVariable(key))
            .Where(string.IsNullOrWhiteSpace)
            .Any()
  )
);

Task(&amp;quot;Build&amp;quot;)
    .Does&amp;lt;BuildData&amp;gt;(
        static (context, data) =&amp;gt; context.DotNetCoreBuild(
          &amp;quot;src&amp;quot;,
          new DotNetCoreBuildSettings {
            MSBuildSettings = new DotNetCoreMSBuildSettings()
              .WithProperty(&amp;quot;Version&amp;quot;, data.Version)
          }
    )
  );

Task(&amp;quot;DPI&amp;quot;)
  .IsDependentOn(&amp;quot;Build&amp;quot;)
  .Does&amp;lt;BuildData&amp;gt;(
      static (context, data) =&amp;gt; context.StartProcess(
        context.Tools.Resolve(&amp;quot;dpi&amp;quot;) ?? context.Tools.Resolve(&amp;quot;dpi.exe&amp;quot;),
        new ProcessSettings {
            Arguments = new ProcessArgumentBuilder()
                                                .Append(&amp;quot;nuget&amp;quot;)
                                                .Append(&amp;quot;--silent&amp;quot;)
                                                .AppendSwitchQuoted(&amp;quot;--output&amp;quot;, &amp;quot;table&amp;quot;)
                                                .Append(data.Analyze ? &amp;quot;analyze&amp;quot; : &amp;quot;report&amp;quot;)
                                                .AppendSwitchQuoted(&amp;quot;--buildversion&amp;quot;, data.Version)
        }
    )
  );

Task(&amp;quot;Default&amp;quot;)
  .IsDependentOn(&amp;quot;DPI&amp;quot;);

RunTarget(Argument(&amp;quot;target&amp;quot;, &amp;quot;Default&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;
&lt;br /&gt;
&lt;h2 id="analyzing-the-data"&gt;Analyzing the data&lt;/h2&gt;
&lt;p&gt;NuGet package references end up as a custom log named &lt;code&gt;NuGetReport_CL&lt;/code&gt; in your Azure Log Analytics Workspace, it will automatically as data is ingested infer types (&lt;code&gt;dates&lt;/code&gt;,&lt;code&gt;strings&lt;/code&gt;, &lt;code&gt;guids&lt;/code&gt;, etc.) and using &lt;a href="https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/?WT.mc_id=AZ-MVP-5002677"&gt;KQL (Kusto Query Language)&lt;/a&gt; you can now start to explore discover, correlate and aggregate.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/03/19/927adaa4-2902-74f1-e587-44377b7131e2.png?sv=2019-12-12&amp;amp;st=2021-03-18T14%3A49%3A47Z&amp;amp;se=2031-03-19T14%3A49%3A47Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=4eUp0%2F4y2jRxH1rCXJbz25%2BteDLSKSuiNv0V9oWti20%3D" alt="Azure Log Analytics Workspace General Logs NuGetReport_CL" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;(Tip there's a &lt;a href="https://docs.microsoft.com/en-us/azure/azure-monitor/logs/log-analytics-tutorial?WT.mc_id=AZ-MVP-5002677"&gt;Log Analytics tutorial&lt;/a&gt; on &lt;a href="https://docs.microsoft.com/en-us/azure/azure-monitor/logs/log-analytics-tutorial?WT.mc_id=AZ-MVP-5002677"&gt;Microsoft Docs&lt;/a&gt; if you're new to Azure Log Analytics)&lt;/em&gt;&lt;/p&gt;
&lt;h3 id="top-5-used-packages"&gt;Top 5 used packages&lt;/h3&gt;
&lt;p&gt;The below query counts unique repositories group by package id and returns the five with the highest package count.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-fsharp"&gt;NuGetReport_CL
| where TimeGenerated &amp;gt;= ago(2d)
| summarize Count = dcount(buildSCM_s) by packageId_s
| order by Count desc, packageId_s asc
| take 5
&lt;/code&gt;&lt;/pre&gt;
&lt;br /&gt;
&lt;h3 id="top-5-used-packages-by-last-report-per-repository"&gt;Top 5 used packages by last report per repository&lt;/h3&gt;
&lt;p&gt;When querying you in general just want the latest set of data per repository, to solve this you can use the fact that each report execution has a unique session-id, and each log has a date/time when ingested.&lt;/p&gt;
&lt;p&gt;By fetching the last session-id we can get a more correct picture of package usage, as a package could have been removed/updated between reports. There are several ways to solve this, in the example below, we use the &lt;a href="https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/arg-max-aggfunction?WT.mc_id=AZ-MVP-5002677"&gt;arg_max&lt;/a&gt; aggregation function to get the session id based on the highest time generated grouped by repository name using the &lt;a href="https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/summarizeoperator?WT.mc_id=AZ-MVP-5002677"&gt;summarize&lt;/a&gt; operator.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-fsharp"&gt;NuGetReport_CL
| where TimeGenerated &amp;gt;= ago(2d)
| summarize arg_max(TimeGenerated, sessionId_g) by buildSCM_s
| join NuGetReport_CL on $left.sessionId_g == $right.sessionId_g
| summarize Count = dcount(buildSCM_s) by packageId_s
| order by Count desc, packageId_s asc
| take 5
&lt;/code&gt;&lt;/pre&gt;
&lt;br /&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/03/20/top5packagesquery.gif?sp=r&amp;amp;st=2021-03-19T11:32:00Z&amp;amp;se=2031-03-21T11:32:00Z&amp;amp;sv=2020-02-10&amp;amp;sr=b&amp;amp;sig=hMWNA6rshw2MfQ8WmufiaLcJ%2FaektrDjnhsu6qotrSo%3D" alt="Query Top 5 used packages by last report per repository" /&gt;&lt;/p&gt;
&lt;br /&gt;
&lt;h3 id="custom-log-nugetreport_cl-columns"&gt;Custom log NuGetReport_CL columns&lt;/h3&gt;
&lt;p&gt;Above were just a couple of examples of NuGet package references queries, but there are almost endless possibilities, and the columns to your disposable are&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;TimeGenerated&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Date/time &lt;strong&gt;UTC&lt;/strong&gt; data ingested&lt;/td&gt;
&lt;td&gt;&lt;code&gt;2021-03-18T15:07:06.46Z&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Computer&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Machine name log generated on&lt;/td&gt;
&lt;td&gt;&lt;code&gt;fv-az68-89&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;buildVersion_s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Value passed using &lt;code&gt;--buildversion&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;2021.03.18.18138&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;buildNo_s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Build number from build provider&lt;/td&gt;
&lt;td&gt;&lt;code&gt;664953123-3544&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;timestamp_t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Date/time &lt;strong&gt;UTC&lt;/strong&gt; data reported&lt;/td&gt;
&lt;td&gt;&lt;code&gt;2021-03-18T15:07:04.798Z&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;platformFamily_s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Operating system reported from&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Linux&lt;/code&gt;, &lt;code&gt;OSX&lt;/code&gt;, &lt;code&gt;Window&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;buildSCM_s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Source control reference&lt;/td&gt;
&lt;td&gt;&lt;code&gt;devlead/DPI&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;buildProvider_s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Build provider&lt;/td&gt;
&lt;td&gt;&lt;code&gt;GitHubActions&lt;/code&gt;, &lt;code&gt;AppVeyor&lt;/code&gt;, &lt;code&gt;AzurePipelinesHosted&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;source_s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Relative file path where references found&lt;/td&gt;
&lt;td&gt;&lt;code&gt;src/DPI/DPI.csproj&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;sourceType_s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Type of source file&lt;/td&gt;
&lt;td&gt;&lt;code&gt;CSProj&lt;/code&gt;, &lt;code&gt;Cake&lt;/code&gt;, &lt;code&gt;DotNetToolsManifest&lt;/code&gt;, &lt;code&gt;PackagesConfig&lt;/code&gt;, &lt;code&gt;ProjectAssets&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;packageId_s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;NuGet package id&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Cake.Bridge.DependencyInjection&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;version_s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;NuGet package version&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0.5.0&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;sessionId_g&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Unique correlation id for each report&lt;/td&gt;
&lt;td&gt;&lt;code&gt;b85f687f-9e34-43c6-8a45-f8b803b373ce&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;targetFramework_s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Package .NET target framework&lt;/td&gt;
&lt;td&gt;&lt;code&gt;net5.0&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;br /&gt;
&lt;h2 id="future"&gt;Future&lt;/h2&gt;
&lt;p&gt;This project was initially done for my own fun and profit, and during that process realized that this can be really useful.&lt;/p&gt;
&lt;p&gt;There's currently no set roadmap, but there are a few things on my radar that I would like to add support for:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Docker images&lt;/li&gt;
&lt;li&gt;NPM packages&lt;/li&gt;
&lt;li&gt;More .NET project types&lt;/li&gt;
&lt;li&gt;SDK versions&lt;/li&gt;
&lt;li&gt;Reporting to more services and formats&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And that I would happily take contributions in form of PRs and issues, the code is open-source and available on GitHub at &lt;a href="https://github.com/devlead/DPI"&gt;github.com/devlead/DPI&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;dpi&lt;/code&gt; is starting to become a really versatile tool, it's a bit abstract to explain, and I've struggled with that a bit with this blog post, but hopefully, I've at least somewhat painted a picture of what's possible, and what problems it can help to solve. I've personally found the process of ingesting &amp;quot;raw&amp;quot; data and then querying both powerful and inspirational, some answers have led to going down rabbit holes of answering new questions.&lt;/p&gt;
&lt;p&gt;Please take it for a spin and if you have any questions, suggestions, or even opinions please feel free to reach out.&lt;/p&gt;
&lt;h2 id="thanks"&gt;Thanks&lt;/h2&gt;
&lt;p&gt;This tool was made possible thanks to a couple of excellent open source projects, special thanks go out to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/spectresystems/spectre.console"&gt;Spectre.Console&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/agc93/spectre.cli.extensions.dependencyinjection"&gt;Spectre.Cli.Extensions.DependencyInjection&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/reactive"&gt;Reactive Extensions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/cake-build/cake/"&gt;Cake&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/devlead/Cake.Bridge.DependencyInjection"&gt;Cake.Bridge.DependencyInjection&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>A DevOps tool to inspect dependencies and report to Azure Log Analytics</summary>
	</entry>
	<entry>
		<id>https://www.devlead.se/posts/2021/2021-03-03-introducing-cake-clickonce-recipe</id>
		<title>Introducing Cake ClickOnce Recipe</title>
		<author>
			<name>devlead</name>
		</author>
		<link href="https://www.devlead.se/posts/2021/2021-03-03-introducing-cake-clickonce-recipe" />
		<link rel="enclosure" type="image" href="https://cdn.devlead.se/clipimg-vscode/2021/01/31/efaa9de4-9e5c-e66b-8b35-3f6b3475b8d3.png?sv=2019-12-12&amp;st=2021-01-30T15%253A03%253A52Z&amp;se=2031-01-31T15%253A03%253A52Z&amp;sr=b&amp;sp=r&amp;sig=wSUYJRdZjnHt0AZ86nc06YeF5eKqwXWAH%252F5525wyiAk%253D" />
		<updated>2021-03-03T00:00:00Z</updated>
		<content>&lt;p&gt;A little over a decade ago I did a lot of business applications with .NET Framework WPF and ClickOnce was in many cases used as a convenient way to deploy and update Windows applications. ClickOnce hasn't gotten much love over the years, and when .NET Core 3 introduced support for WPF applications ClickOnce support was nowhere to be found. But guess what, that's changed with .NET 5 and in this post, I'll go through my recipe for simplifying the building and publishing .NET 5 Windows application using GitHub Actions, Cake, and ClickOnce to Azure Blob Storage.&lt;/p&gt;
&lt;h2 id="cake-recipe"&gt;Cake Recipe?&lt;/h2&gt;
&lt;p&gt;So what is a Cake recipe? Regardless of what it sounds like, it in this case has nothing to do with baking, but it's a set of &lt;a href="https://cakebuild.net/"&gt;Cake&lt;/a&gt; scripts packaged as NuGet package and published on NuGet.org, providing a highly reusable way to with just a few lines of code get access to rich functionality.&lt;/p&gt;
&lt;p&gt;For example this recipe will for a .NET 5 based Windows application, in a very optioned way&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Version application&lt;/li&gt;
&lt;li&gt;Build application&lt;/li&gt;
&lt;li&gt;Create ClickOnce assets&lt;/li&gt;
&lt;li&gt;Deploy to Azure Blob storage&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="sample-application"&gt;Sample application&lt;/h2&gt;
&lt;p&gt;For simplicity I'm here going to use the standard .NET 5 WPF template, using .NET CLI that would look something like below&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet new wpf -n MyApp
dotnet new sln -n MyApp
dotnet sln add MyApp/MyApp.csproj
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which essentially:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Creates project&lt;/li&gt;
&lt;li&gt;Creates solution&lt;/li&gt;
&lt;li&gt;Adds project to solution&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Which is similar to &lt;em&gt;New Project -&amp;gt; WPF Application (C# / Windows / Desktop .NET Core)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/31/9348f210-84a6-74b2-5f9f-6f31e20b1877.png?sv=2019-12-12&amp;amp;st=2021-01-30T17%3A12%3A36Z&amp;amp;se=2031-01-31T17%3A12%3A36Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=YnOmvtwboOr30u0v1EnSsdpBpJnHl%2FcwEIKr9p%2FAQ1Y%3D" alt="Create new project in Visual Studio 2019" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/31/6dadc800-fcc0-31ab-f4f3-9446b5f5c411.png?sv=2019-12-12&amp;amp;st=2021-01-30T17%3A13%3A34Z&amp;amp;se=2031-01-31T17%3A13%3A34Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=jdfRM7ANfxT8XyzhzfXKZfv2U8JV%2B%2Bl%2BREX4ALUpdiM%3D" alt=".NET Core WPF Application Template" /&gt;&lt;/p&gt;
&lt;p&gt;Resulting in a bare minimum folder/file structure like below&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text"&gt;src
 │    MyApp.sln
 │
 └─── MyApp
        App.xaml
        App.xaml.cs
        AssemblyInfo.cs
        MainWindow.xaml
        MainWindow.xaml.cs
        MyApp.csproj
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="adding-cake.clickonce.recipe"&gt;Adding Cake.ClickOnce.Recipe&lt;/h2&gt;
&lt;p&gt;Now that we have our sample application, let's rub some DevOps on it using Cake.ClickOnce.Recipe.&lt;/p&gt;
&lt;h3 id="prerequisites"&gt;Prerequisites&lt;/h3&gt;
&lt;h4 id="tools"&gt;Tools&lt;/h4&gt;
&lt;p&gt;To run our recipe we need one .NET tool installed&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Cake.Tool 1.0.0 or newer&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;My preferred way is to install using a .NET tool manifest in repo root, so the tools are versioned and restored within the repo, a manifest is easiest created using the .NET CLI template &lt;code&gt;tool-manifest&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet new tool-manifest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and then install the tool&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet tool install Cake.Tool
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="azure"&gt;Azure&lt;/h4&gt;
&lt;p&gt;The recipe uses Azure Blob Storage to distribute the application and ClickOnce manifest, so you'll need to create:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Azure Storage Account&lt;/li&gt;
&lt;li&gt;Container with anonymous read access for blobs only&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/31/2afa2bbc-0d9a-7898-d056-d9a221d8dc1d.png?sv=2019-12-12&amp;amp;st=2021-01-30T20%3A42%3A16Z&amp;amp;se=2031-01-31T20%3A42%3A16Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=Kx6eIPJh9ZHdOvWEeP6GJl%2BChVgyrR21%2FO7qlEJ7us4%3D" alt="New Storage Collage" /&gt;&lt;/p&gt;
&lt;h3 id="adding-recipe"&gt;Adding recipe&lt;/h3&gt;
&lt;p&gt;In repo root create a &lt;code&gt;build.cake&lt;/code&gt; file containing&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;#load &amp;quot;nuget:?package=Cake.ClickOnce.Recipe&amp;amp;version=0.2.0&amp;quot;

ClickOnce.ApplicationName = &amp;quot;MyApp&amp;quot;;
ClickOnce.Publisher = &amp;quot;devlead&amp;quot;;
ClickOnce.PublishUrl = &amp;quot;https://cakeclickonceexample.blob.core.windows.net/publish&amp;quot;;
ClickOnce.RunBuild();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The Recipe has three required settings&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;ApplicationName&lt;/code&gt; - in general same as project name&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Publisher&lt;/code&gt; - name of publisher&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PublishUrl&lt;/code&gt; - base url for where application is installed from, in this case Azure Blob Storage container url&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="local-build"&gt;Local build&lt;/h2&gt;
&lt;p&gt;We're now all set to kick of a local build using Cake&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet cake
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and if all goes well you should see something like below&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text"&gt;Task                           Duration
---------------------------------------------------
Setup                          00:00:00.0070864
Clean                          00:00:00.0114975
Restore                        00:00:01.0136714
Build                          00:00:02.6537503
Publish                        00:00:00.9728737
ClickOnce-Launcher             00:00:00.3629962
ClickOnce-Application-Manifest 00:00:00.5536790
ClickOnce-Deployment-Manifest  00:00:00.5924181
---------------------------------------------------
Total:                         00:00:06.1730701
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and a new folder in repo root called artifacts containing application ClickOnce manifest and a date versioned folder (you can override the generated version using &lt;code&gt;ClickOnce.Version&lt;/code&gt; property).&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text"&gt;artifacts
 │   MyApp.application
 │
 └───MyApp.2021.01.31.25014
        Launcher.exe
        MyApp.deps.json
        MyApp.dll
        MyApp.exe
        MyApp.manifest
        MyApp.pdb
        MyApp.runtimeconfig.json
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="github-actions"&gt;GitHub Actions&lt;/h2&gt;
&lt;p&gt;A fairly minimal GitHub Actions could essentially be&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Checkout source&lt;/li&gt;
&lt;li&gt;Install .NET SDK&lt;/li&gt;
&lt;li&gt;Install &amp;amp; Execute Cake&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="build-definition"&gt;Build definition&lt;/h3&gt;
&lt;p&gt;The yaml build definition could look something like below&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;name: Build
on:
  pull_request:
  push:
    branches:
      - main
      - develop

jobs:
  build:
    name: Build
    runs-on: windows-latest
    steps:
      - name: Get the sources
        uses: actions/checkout&amp;#64;v2

      - name: Install .NET Core SDK
        uses: actions/setup-dotnet&amp;#64;v1

      - name: Run Cake script
        env:
          PUBLISH_STORAGE_ACCOUNT: ${{ secrets.PUBLISH_STORAGE_ACCOUNT }}
          PUBLISH_STORAGE_CONTAINER: ${{ secrets.PUBLISH_STORAGE_CONTAINER }}
          PUBLISH_STORAGE_KEY: ${{ secrets.PUBLISH_STORAGE_KEY }}
        run: |
          dotnet tool restore
          dotnet cake
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;Run Cake script&lt;/code&gt; step has three environment variables defined&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PUBLISH_STORAGE_ACCOUNT&lt;/code&gt; - Azure storage account name i.e. &lt;code&gt;cakeclickonceexample&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PUBLISH_STORAGE_CONTAINER&lt;/code&gt; - Azure storage container name i.e. &lt;code&gt;publish&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PUBLISH_STORAGE_KEY&lt;/code&gt; - Azure storage account secondary or primary key.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These are fetched from your GitHub repo settings Secrets section, which means they're not publicly stored anywhere in the repo and also not available from pull requests.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/03/02/8ebf213e-1f0d-8d68-d12d-58ceafe6d728.png?sv=2019-12-12&amp;amp;st=2021-03-01T21%3A51%3A01Z&amp;amp;se=2031-03-02T21%3A51%3A01Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=U%2BCyMGwq5x66LcKonxmi%2FjD52btWXph5Ku2P33T8rGE%3D" alt="GitHub Repo Secrets settings" /&gt;&lt;/p&gt;
&lt;h3 id="output-example-on-github-actions"&gt;Output Example on GitHub Actions&lt;/h3&gt;
&lt;p&gt;The recipe will automatically identify that it's executing on GitHub Actions, and execute a few extra steps to upload and point the ClickOnce manifest to the new version.&lt;/p&gt;
&lt;p&gt;If all goes well GitHub Actions output would look something like below&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;
----------------------------------------
Setup
----------------------------------------
Setting up version 2021.01.27.18139
▶ &amp;quot;Clean&amp;quot;
▶ &amp;quot;Restore&amp;quot;
▶ &amp;quot;Build&amp;quot;
▶ &amp;quot;Publish&amp;quot;
▶ &amp;quot;ClickOnce-Launcher&amp;quot;
▶ &amp;quot;ClickOnce-Application-Manifest&amp;quot;
▶ &amp;quot;ClickOnce-Deployment-Manifest&amp;quot;
▶ &amp;quot;ClickOnce-Deployment-UpdateManifest&amp;quot;
▶ &amp;quot;ClickOnce-Deployment-CreateAppRef&amp;quot;
▶ &amp;quot;ClickOnce-Upload-Version&amp;quot;
▶ &amp;quot;ClickOnce-Upload-Application&amp;quot;
▶ &amp;quot;Publish-ClickOnce&amp;quot;

Task                                Duration
--------------------------------------------------------
Setup                               00:00:00.0160939
Clean                               00:00:00.0084806
Restore                             00:00:02.1274733
Build                               00:00:03.3076849
Publish                             00:00:01.2192429
ClickOnce-Launcher                  00:00:00.4506914
ClickOnce-Application-Manifest      00:00:00.6510728
ClickOnce-Deployment-Manifest       00:00:00.9086913
ClickOnce-Deployment-UpdateManifest 00:00:00.6800874
ClickOnce-Deployment-CreateAppRef   00:00:00.0112772
ClickOnce-Upload-Version            00:00:02.1736495
ClickOnce-Upload-Application        00:00:00.6269294
--------------------------------------------------------
Total:                              00:00:12.1814083
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and you now have a fully automated build and release of your ClickOnce application.&lt;/p&gt;
&lt;h2 id="installing-application"&gt;Installing application&lt;/h2&gt;
&lt;p&gt;The recipe will automatically generate an &lt;code&gt;appref-ms&lt;/code&gt; file, downloading and opening this file from blob storage is enough to trigger the ClickOnce runtime and install the application.&lt;/p&gt;
&lt;p&gt;Example: &lt;a href="https://cakeclickonceexample.blob.core.windows.net/publish/MyApp.appref-ms"&gt;cakeclickonceexample.blob.core.windows.net/publish/MyApp.appref-ms&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/03/02/installclickonce.gif?sp=r&amp;amp;st=2021-03-01T23:03:03Z&amp;amp;se=2031-03-03T07:03:03Z&amp;amp;spr=https&amp;amp;sv=2020-02-10&amp;amp;sr=b&amp;amp;sig=hSBI7hfdtkWR0SqdX5yiHDeE9E%2FwZzWCEHTZqp518Ls%3D" alt="ClickOnce installation example" /&gt;&lt;/p&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Long story short, the recipe greatly simplifies the automation of building a WPF application, getting it published and deployed using ClickOnce technologies - achieving this only configuring the bare minimum what's needed to do so.&lt;/p&gt;
&lt;p&gt;There's still a lot of work to do with the recipe especially around signing, icons, etc.&lt;/p&gt;
&lt;p&gt;That said it's fully functional and a good starting point.
The recipe is open source, so I'll happily take feedback and contributions to improve it.&lt;/p&gt;
&lt;h2 id="resources"&gt;Resources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Recipe source on GitHub - &lt;a href="https://github.com/devlead/Cake.ClickOnce.Recipe"&gt;github.com/devlead/Cake.ClickOnce.Recipe&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Recipe on NuGet.org - &lt;a href="https://www.nuget.org/packages/Cake.ClickOnce.Recipe/"&gt;nuget.org/packages/Cake.ClickOnce.Recipe&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Example repository on GitHub - &lt;a href="https://github.com/devlead/Cake.ClickOnce.Recipe.Example"&gt;github.com/devlead/Cake.ClickOnce.Recipe.Example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Cake - &lt;a href="https://cakebuild.net/"&gt;cakebuild.net&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>An opinionated recipe for building and publishing .NET 5 Windows apps</summary>
	</entry>
	<entry>
		<id>https://www.devlead.se/posts/2021/2021-01-15-my-preferred-console-stack</id>
		<title>My preferred .NET console stack</title>
		<author>
			<name>devlead</name>
		</author>
		<link href="https://www.devlead.se/posts/2021/2021-01-15-my-preferred-console-stack" />
		<link rel="enclosure" type="image" href="https://cdn.devlead.se/clipimg-vscode/2021/01/14/e02ce155-5ff2-8a7b-e306-8c486f23f864.png?sv=2019-12-12&amp;st=2021-01-13T20%253A33%253A10Z&amp;se=2031-01-14T20%253A33%253A10Z&amp;sr=b&amp;sp=r&amp;sig=fdANWdytZGRdgDMxN%252B%252BTNSCAbz%252Bzg6R0iAvtvYWYoKw%253D" />
		<updated>2021-01-15T00:00:00Z</updated>
		<content>&lt;p&gt;There's type of application that has followed me since I learned to code in the mid-'80s, and that's the console application. For years they looked the same a &lt;code&gt;Main(string[] args)&lt;/code&gt; and some naive inconsistent command line parser. That gradually improved with the adoption of various OSS helper libraries. In this post, I'll walk through what today is my alternative starting point to &lt;code&gt;dotnet new console&lt;/code&gt;, a way that greatly reduces the boilerplate code needed for logging, parsing, and validation of arguments, letting me focus on the problem to solve and not the plumbing.&lt;/p&gt;
&lt;h2 id="templates"&gt;Templates&lt;/h2&gt;
&lt;p&gt;A convenient way to scaffold a new project is using the template function of .NET SDK CLI, it comes preloaded with several templates like &lt;code&gt;console&lt;/code&gt;, &lt;code&gt;classlib&lt;/code&gt;, etc., but beyond that, it's possible to create your own templates, which I've for my and your convenience created, so given &lt;a href="https://dotnet.microsoft.com/download/dotnet/5.0"&gt;.NET 5 SDK&lt;/a&gt; installed, easily yourself can try and take a look at everything discussed in this post.&lt;/p&gt;
&lt;h2 id="devlead-console-template"&gt;Devlead Console Template&lt;/h2&gt;
&lt;p&gt;So let's get started with creating a new console application according to my opinionated recipe, .NET SDK Templates are distributed as NuGet packages and the canonical source for NuGet packages is &lt;a href="https://www.nuget.org/"&gt;NuGet.org&lt;/a&gt;, where I've published my template as &lt;a href="https://www.nuget.org/packages/Devlead.Console.Template/"&gt;Devlead.Console.Template&lt;/a&gt;. Templates are installed using the &lt;code&gt;dotnet new&lt;/code&gt; command with &lt;code&gt;--install packageId&lt;/code&gt; parameter, in this case:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet new --install Devlead.Console.Template
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="dotnet-new-devleadconsole"&gt;dotnet new devleadconsole&lt;/h2&gt;
&lt;p&gt;With the template installed locally, we now have a new &lt;code&gt;devleadconsole&lt;/code&gt; template at our disposal, to create our new console applications with according to me, essential dependencies and boilerplate code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet new devleadconsole -n MyConsoleApp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above command will in the current directory result in the below folder structure&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text"&gt;MyConsoleApp
    │   MyConsoleApp.csproj
    │   Program.cs
    │
    └───Commands
        │   ConsoleCommand.cs
        │
        ├───Settings
        │       ConsoleSettings.cs
        │
        └───Validation
                ValidateStringAttribute.cs
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="myconsoleapp.csproj"&gt;MyConsoleApp.csproj&lt;/h2&gt;
&lt;p&gt;The created project file will look something like below&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;Project Sdk=&amp;quot;Microsoft.NET.Sdk&amp;quot;&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt;
    &amp;lt;TargetFramework&amp;gt;net5.0&amp;lt;/TargetFramework&amp;gt;
    &amp;lt;Nullable&amp;gt;enable&amp;lt;/Nullable&amp;gt;
    &amp;lt;TreatWarningsAsErrors&amp;gt;true&amp;lt;/TreatWarningsAsErrors&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Spectre.Console&amp;quot; Version=&amp;quot;0.37.0&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Spectre.Cli.Extensions.DependencyInjection&amp;quot; Version=&amp;quot;0.3.0&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.Extensions.Logging&amp;quot; Version=&amp;quot;5.0.0&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.Extensions.Logging.Console&amp;quot; Version=&amp;quot;5.0.0&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.SourceLink.GitHub&amp;quot; Version=&amp;quot;1.0.0&amp;quot; PrivateAssets=&amp;quot;All&amp;quot;/&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;let's step for step break it down&lt;/p&gt;
&lt;h3 id="outputtype"&gt;OutputType&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;OutputType&lt;/code&gt; with the value &lt;code&gt;exe&lt;/code&gt;, indicates that this will be an executable.&lt;/p&gt;
&lt;h3 id="targetframework"&gt;TargetFramework&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;TargetFramework&lt;/code&gt; with the value &lt;code&gt;net5.0&lt;/code&gt;, means that this will be compiled for/targeting .NET 5.&lt;/p&gt;
&lt;h3 id="nullable"&gt;Nullable&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Nullable&lt;/code&gt; with the value &lt;code&gt;enable&lt;/code&gt;, enables the &lt;a href="https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references"&gt;nullable reference types&lt;/a&gt; feature that was introduced with C# 8, making reference types non-nullable by default, basically moving many errors from being caught late at runtime, to be caught early at compile time.&lt;/p&gt;
&lt;h3 id="treatwarningsaserrors"&gt;TreatWarningsAsErrors&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;TreatWarningsAsErrors&lt;/code&gt; with the value &lt;code&gt;true&lt;/code&gt; makes the compiler grumpier, it won't just break the build for compiler errors, but also for compiler warnings, combined with &lt;code&gt;Nullable&lt;/code&gt; I personally believe code quality gets better from the start.&lt;/p&gt;
&lt;h3 id="packagereferences"&gt;PackageReference(s)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://www.nuget.org/packages/Spectre.Console"&gt;Spectre.Console&lt;/a&gt;&lt;/strong&gt; is a lot of things, a true swiss army for anyone doing console applications, but in this template, it's foremost an extremely opinionated command-line parser.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://www.nuget.org/packages/Spectre.Cli.Extensions.DependencyInjection"&gt;Spectre.Cli.Extensions.DependencyInjection&lt;/a&gt;&lt;/strong&gt; makes it easy for &lt;a href="https://www.nuget.org/packages/Spectre.Console"&gt;Spectre.Console&lt;/a&gt; to interop with standard &lt;strong&gt;&lt;a href="https://www.nuget.org/packages/Microsoft.Extensions.DependencyInjection/"&gt;Microsoft DependencyInjection&lt;/a&gt;&lt;/strong&gt;, same as used by default for dependency injection with i.e. ASP .NET and Azure Functions.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://www.nuget.org/packages/Microsoft.Extensions.Logging"&gt;Microsoft.Extensions.Logging&lt;/a&gt;&lt;/strong&gt; simplified provides standard logging abstractions and &lt;strong&gt;&lt;a href="https://www.nuget.org/packages/Microsoft.Extensions.Logging.Console"&gt;Microsoft.Extensions.Logging.Console&lt;/a&gt;&lt;/strong&gt; provides an implementation for logging to the console.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://www.nuget.org/packages/Microsoft.SourceLink.GitHub"&gt;Microsoft.SourceLink.GitHub&lt;/a&gt;&lt;/strong&gt; enables automatic tracking between artifact and source control, providing a better debugging and traceability experience.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="program.cs"&gt;Program.cs&lt;/h2&gt;
&lt;p&gt;The generated &lt;code&gt;Program.cs&lt;/code&gt; uses the new C#9 &lt;a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9#top-level-statements"&gt;Top-level statement&lt;/a&gt; pattern removing unnecessary ceremony code from the application, but what it does contain:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;using statements&lt;/li&gt;
&lt;li&gt;Creating dependency injection container&lt;/li&gt;
&lt;li&gt;Console logger registration&lt;/li&gt;
&lt;li&gt;Hooking up dependency injection container with Spectre.Console&lt;/li&gt;
&lt;li&gt;Spectre.Console command declaration&lt;/li&gt;
&lt;li&gt;Execute the application&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;Note: &lt;a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9#top-level-statements"&gt;Top-level statement&lt;/a&gt;  means as &lt;code&gt;RunAsync&lt;/code&gt; returns a &lt;code&gt;Task&amp;lt;int&amp;gt;&lt;/code&gt;, .NET 5 will automatically generate &amp;quot;&lt;code&gt;Program&lt;/code&gt;&amp;quot; class and &lt;code&gt;async Task&amp;lt;int&amp;gt; Main(string args)&lt;/code&gt; for you, removing the need to write a lot of boilerplate code.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Devlead.Console.Commands;
using Spectre.Console.Cli;
using Spectre.Cli.Extensions.DependencyInjection;

var serviceCollection = new ServiceCollection()
    .AddLogging(configure =&amp;gt;
            configure
                .AddSimpleConsole(opts =&amp;gt; {
                    opts.TimestampFormat = &amp;quot;yyyy-MM-dd HH:mm:ss &amp;quot;;
                })
    );

using var registrar = new DependencyInjectionRegistrar(serviceCollection);
var app = new CommandApp(registrar);

app.Configure(
    config =&amp;gt;
    {
        config.ValidateExamples();

        config.AddCommand&amp;lt;ConsoleCommand&amp;gt;(&amp;quot;console&amp;quot;)
                .WithDescription(&amp;quot;Example console command.&amp;quot;)
                .WithExample(new[] { &amp;quot;console&amp;quot; });
    });

return await app.RunAsync(args);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="consolecommand.cs"&gt;ConsoleCommand.cs&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ConsoleCommand.cs&lt;/code&gt; contains &amp;quot;just&amp;quot; your business code, &lt;a href="https://spectresystems.github.io/spectre.console/"&gt;Spectre.Console&lt;/a&gt; handles the heavy lifting of parsing and validating command-line arguments (&lt;em&gt;based on provided settings class, more on that later in the post.&lt;/em&gt;), resolving constructor parameters using dependency injection, etc. Letting you focus on the domain and not the boilerplate code, resulting in a very similar experience to i.e. Azure Function or .NET Workers, enabling reuse of both patterns and code. &lt;a href="https://spectresystems.github.io/spectre.console/"&gt;Spectre.Console&lt;/a&gt; has support for both async and sync commands.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using MyConsoleApp.Commands.Setting;
using Spectre.Console.Cli;

namespace MyConsoleApp.Commands
{
    public class ConsoleCommand : AsyncCommand&amp;lt;ConsoleSettings&amp;gt;
    {
        private ILogger Logger { get; }

        public override async Task&amp;lt;int&amp;gt; ExecuteAsync(CommandContext context, ConsoleSettings settings)
        {
            Logger.LogInformation(&amp;quot;Mandatory: {Mandatory}&amp;quot;, settings.Mandatory);
            Logger.LogInformation(&amp;quot;Optional: {Optional}&amp;quot;, settings.Optional);
            Logger.LogInformation(&amp;quot;CommandOptionFlag: {CommandOptionFlag}&amp;quot;, settings.CommandOptionFlag);
            Logger.LogInformation(&amp;quot;CommandOptionValue: {CommandOptionValue}&amp;quot;, settings.CommandOptionValue);
            return await Task.FromResult(0);
        }

        public ConsoleCommand(ILogger&amp;lt;ConsoleCommand&amp;gt; logger)
        {
            Logger = logger;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="consolesettings.cs"&gt;ConsoleSettings.cs&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ConsoleSettings.cs&lt;/code&gt; contains the definition of what parameters each command has, if they're are mandatory/optional, positional and how they validated. It also contains metadata used for automatically generating help and error messages.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using System.ComponentModel;
using Devlead.Console.Commands.Validate;
using Spectre.Console.Cli;

namespace Devlead.Console.Commands.Setting
{
    public class ConsoleSettings : CommandSettings
    {
        [CommandArgument(0, &amp;quot;&amp;lt;mandatory&amp;gt;&amp;quot;)]
        [Description(&amp;quot;Mandatory argument&amp;quot;)]
        public string Mandatory { get; set; } = string.Empty;

        [CommandArgument(1, &amp;quot;[optional]&amp;quot;)]
        [Description(&amp;quot;Optional argument&amp;quot;)]
        public string? Optional { get; set; }

        [CommandOption(&amp;quot;--command-option-flag&amp;quot;)]
        [Description(&amp;quot;Command option flag.&amp;quot;)]
        public bool CommandOptionFlag { get; set; }

        [CommandOption(&amp;quot;--command-option-value &amp;lt;value&amp;gt;&amp;quot;)]
        [Description(&amp;quot;Command option value.&amp;quot;)]
        [ValidateString]
        public string? CommandOptionValue { get; set; }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="validatestringattribute.cs"&gt;ValidateStringAttribute.cs&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://spectresystems.github.io/spectre.console/"&gt;Spectre.Console&lt;/a&gt; can validate either by custom attributes on properties (&lt;em&gt;see &lt;code&gt;ConsoleSettings.CommandOptionValue&lt;/code&gt; for an example of that&lt;/em&gt;) or globally by overriding &lt;code&gt;Validate()&lt;/code&gt; method on &lt;code&gt;CommandSettings&lt;/code&gt;. The template ships with a sample &lt;code&gt;ValidateStringAttribute&lt;/code&gt; that just validates the length of a string, but you can make it as advanced as you want.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using Spectre.Console;
using Spectre.Console.Cli;

namespace MyConsoleApp.Commands.Validation
{
    public class ValidateStringAttribute : ParameterValidationAttribute
    {
        public const int MinimumLength = 3;

        public ValidateStringAttribute() : base(errorMessage: null)
        {
        }

        public override ValidationResult Validate(ICommandParameterInfo parameterInfo, object? value)
            =&amp;gt; (value as string) switch {
                { Length: &amp;gt;= MinimumLength }
                    =&amp;gt; ValidationResult.Success(),

                { Length: &amp;lt; MinimumLength }
                    =&amp;gt; ValidationResult.Error($&amp;quot;{parameterInfo?.PropertyName} ({value}) needs to be at least {MinimumLength} characters long.&amp;quot;),

                _ =&amp;gt; ValidationResult.Error($&amp;quot;Invalid {parameterInfo?.PropertyName} ({value}) specified.&amp;quot;)
            };
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="result"&gt;Result&lt;/h2&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/15/devleadmyconsoleapp.gif?sp=rl&amp;amp;st=2021-01-15T09:33:29Z&amp;amp;se=2031-01-16T09:33:00Z&amp;amp;sv=2019-12-12&amp;amp;sr=b&amp;amp;sig=fp8lXgfDwOgGkdK3cYm0fFojddT8ZEx7SJuiIMkIOW8%3D" alt="GIF animation of Console experience" /&gt;&lt;/p&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;This is my opinionated happy path for doing .NET Console applications, feel free to let me know if you've got your own recipe for success, but must say I'm really happy how this combination lets me write console applications in the same way as I do my .NET workers, Azure Functions, ASP .NET Core, etc. ensuring consistency, less duplication and good reuse of both patterns and code. There's a LOT more to &lt;a href="https://spectresystems.github.io/spectre.console/"&gt;Spectre.Console&lt;/a&gt; than command-line parsing, to I hight recommend you check out all the other features it has to offer.&lt;/p&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/devlead/Devlead.Console.Template"&gt;Devlead.Console.Template&lt;/a&gt; (&lt;a href="https://www.nuget.org/packages/Devlead.Console.Template"&gt;NuGet&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://spectresystems.github.io/spectre.console/"&gt;Spectre.Console&lt;/a&gt; (&lt;a href="https://www.nuget.org/packages/Spectre.Console"&gt;NuGet&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/agc93/spectre.cli.extensions.dependencyinjection#spectrecliextensionsdependencyinjection"&gt;Spectre.Cli.Extensions.DependencyInjection&lt;/a&gt; (&lt;a href="https://www.nuget.org/packages/Spectre.Cli.Extensions.DependencyInjection"&gt;NuGet&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-5.0"&gt;Dependency injection in ASP.NET Core&lt;/a&gt; (&lt;a href="https://www.nuget.org/packages/Microsoft.Extensions.DependencyInjection/"&gt;NuGet&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/sourcelink#source-link"&gt;Source Link&lt;/a&gt; (&lt;a href="https://www.nuget.org/packages/Microsoft.SourceLink.GitHub"&gt;NuGet&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-5.0"&gt;Logging in .NET Core and ASP.NET Core&lt;/a&gt; (&lt;a href="https://www.nuget.org/packages/Microsoft.Extensions.Logging.Console"&gt;NuGet&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>An opinionated view on the boilerplate starting point of any .NET console application</summary>
	</entry>
	<entry>
		<id>https://www.devlead.se/posts/2021/2021-01-12-introducing-cake-bridge-dependency-injection</id>
		<title>Introducing Cake Bridge Dependency Injection</title>
		<author>
			<name>devlead</name>
		</author>
		<link href="https://www.devlead.se/posts/2021/2021-01-12-introducing-cake-bridge-dependency-injection" />
		<link rel="enclosure" type="image" href="https://cdn.devlead.se/clipimg-vscode/2021/01/12/c2a643e9-2c63-361b-b458-a647352ebe87.png?sv=2019-12-12&amp;st=2021-01-11T10%253A13%253A57Z&amp;se=2031-01-12T10%253A13%253A57Z&amp;sr=b&amp;sp=r&amp;sig=qInj%252F3o1X2jmpZR1KQIWUgaYF5S8c9zJz0l7zZVYmWg%253D" />
		<updated>2021-01-12T00:00:00Z</updated>
		<content>&lt;p&gt;A couple of years ago I blogged &lt;a href="https://www.devlead.se/posts/2017/2017-07-09-dispelling-the-magic"&gt;Dispelling the magic!&lt;/a&gt;, a post explaining the internals of the &lt;a href="https://cakebuild.net/"&gt;Cake&lt;/a&gt; build orchestration tool, with that post as a proof of concept I created &lt;a href="https://www.nuget.org/packages/Cake.Bridge"&gt;Cake.Bridge&lt;/a&gt; assembly which provided an easy way from any .NET language get access to Cake abstractions and addins from a single instance static class.&lt;/p&gt;
&lt;h2 id="the-need"&gt;The Need&lt;/h2&gt;
&lt;p&gt;Cake has some real nice testable abstractions around working with the filesystem, processes, tools, etc. and for a .NET project, we had just that need. But a static instance isn't very testable, and for most of our .NET projects (console apps, APIs, Azure Functions, WPF, etc.) we now use dependency injection using &lt;a href="https://www.nuget.org/packages/Microsoft.Extensions.DependencyInjection/"&gt;Microsoft.Extensions.DependencyInjection&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;So with that in mind, I created an extension method to &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.iservicecollection?view=dotnet-plat-ext-5.0"&gt;IServiceCollection&lt;/a&gt; that easily provided me a way to get a &lt;a href="https://cakebuild.net/api/Cake.Core.IO/IFileSystem/"&gt;IFileSystem&lt;/a&gt; injected and utilizing the &lt;a href="https://cakebuild.net/api/Cake.Testing/FakeFileSystem/"&gt;FakeFileSystem&lt;/a&gt; provided by &lt;a href="https://www.nuget.org/packages/Cake.Testing"&gt;Cake.Testing&lt;/a&gt; for testing.
That grew into supporting most core Cake types including the more complex &lt;a href="https://cakebuild.net/api/Cake.Core/ICakeContext/"&gt;ICakeContext&lt;/a&gt; and &lt;a href="https://cakebuild.net/api/Cake.Core.Scripting/IScriptHost/"&gt;IScriptHost&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="introducing-cake.bridge.dependencyinjection"&gt;Introducing Cake.Bridge.DependencyInjection&lt;/h2&gt;
&lt;p&gt;If we got a need, chances are someone else has it too, so I've open-sourced the code and made it available as a NuGet &lt;a href="https://www.nuget.org/packages/Cake.Bridge.DependencyInjection/"&gt;package&lt;/a&gt;. It's early bits tailored for a specific need, so you should expect some rough edges, but sharing is caring.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;h3 id="obtain"&gt;Obtain&lt;/h3&gt;
&lt;p&gt;The assembly is published at &lt;a href="https://www.nuget.org/packages/Cake.Bridge.DependencyInjection"&gt;NuGet.org/packages/Cake.Bridge.DependencyInjection&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id="net-cli"&gt;.NET CLI&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet add package Cake.Bridge.DependencyInjection
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="packagereference"&gt;PackageReference&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;PackageReference Include="Cake.Bridge.DependencyInjection" Version="0.1.0" /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="register"&gt;Register&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using Cake.Bridge.DependencyInjection;
...
serviceCollection
    .AddCakeCore();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="resolve"&gt;Resolve&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using Cake.Core;
...
var cakeContext = serviceProvider.GetRequiredService&amp;lt;ICakeContext&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="use"&gt;Use&lt;/h3&gt;
&lt;p&gt;Once registered you can now via dependency injection access the majority &lt;a href="https://cakebuild.net/api/Cake.Core/#InterfaceTypes"&gt;Cake.Core&lt;/a&gt; interfaces with ease, i.e:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://cakebuild.net/api/Cake.Core/ICakeContext/"&gt;ICakeContext&lt;/a&gt; - Gives access to Cake built-in and addin aliases, and most Cake abstractions.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://cakebuild.net/api/Cake.Core.Scripting/IScriptHost/"&gt;IScriptHost&lt;/a&gt; - Gives access to script/task runner.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://cakebuild.net/api/Cake.Core.Diagnostics/ICakeLog/"&gt;ICakeLog&lt;/a&gt; - Cake logging implementation.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://cakebuild.net/api/Cake.Core.IO/IFileSystem/"&gt;IFileSystem&lt;/a&gt; - Cake file system abstraction.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="example-icakecontext"&gt;Example ICakeContext&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using Cake.Bridge.DependencyInjection;
using Cake.Core;
using Cake.Core.Diagnostics;
using Microsoft.Extensions.DependencyInjection;

var serviceCollection = new ServiceCollection()
    .AddCakeCore();

var serviceProvider = serviceCollection.BuildServiceProvider();

var cakeContext = serviceProvider.GetRequiredService&amp;lt;ICakeContext&amp;gt;();

cakeContext.Log.Write(
    Verbosity.Normal,
    LogLevel.Information,
    "Hello World!");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;will output&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;Hello World!
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="example-iscripthost-and-cake.common"&gt;Example IScriptHost and Cake.Common&lt;/h3&gt;
&lt;p&gt;Cake.Common contains Cake aliases normally ships together with the Cake script runner, when using Cake Bridge you'll need to add it to you project (same for any Cake addin).&lt;/p&gt;
&lt;h4 id="net-cli-1"&gt;.NET CLI&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet add package Cake.Common --version 1.0.0-rc0002
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="packagereference-1"&gt;PackageReference&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;PackageReference Include="Cake.Common" Version="1.0.0-rc0002" /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;then add the appropriate using statements and you can achieve something very similar to a Cake "script"&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using Cake.Bridge.DependencyInjection;
using Cake.Core;
using Cake.Common.Diagnostics;
using Cake.Core.Scripting;
using Microsoft.Extensions.DependencyInjection;

var serviceCollection = new ServiceCollection()
    .AddCakeCore();

var serviceProvider = serviceCollection.BuildServiceProvider();

var scriptHost = serviceProvider.GetRequiredService&amp;lt;IScriptHost&amp;gt;();

scriptHost.Task("Hello")
    .Does(ctx =&amp;gt; ctx.Information("Hello"));

scriptHost.Task("World")
    .IsDependentOn("Hello")
    .Does(ctx =&amp;gt; ctx.Information("World"));

await scriptHost.RunTargetAsync("World");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;will output&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;========================================
Hello
========================================
Hello

========================================
World
========================================
World

Task                          Duration
--------------------------------------------------
Hello                         00:00:00.0226275
World                         00:00:00.0002682
--------------------------------------------------
Total:                        00:00:00.0228957
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="complete-example-project"&gt;Complete example project&lt;/h3&gt;
&lt;p&gt;A full example console application using &lt;a href="https://www.nuget.org/packages/Spectre.Console"&gt;Spectre.Console&lt;/a&gt; demonstrating usage of both &lt;a href="https://cakebuild.net/api/Cake.Core/ICakeContext/"&gt;ICakeContext&lt;/a&gt; and &lt;a href="https://cakebuild.net/api/Cake.Core.Scripting/IScriptHost/"&gt;IScriptHost&lt;/a&gt; can be found in project's GitHub &lt;a href="https://github.com/devlead/Cake.Bridge.DependencyInjection"&gt;repository&lt;/a&gt; at &lt;a href="https://github.com/devlead/Cake.Bridge.DependencyInjection/tree/develop/src/Cake.Bridge.DependencyInjection.Example"&gt;src/Cake.Bridge.DependencyInjection.Example&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="resources"&gt;Resources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;GitHub - &lt;a href="https://github.com/devlead/Cake.Bridge.DependencyInjection"&gt;github.com/devlead/Cake.Bridge.DependencyInjection&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;NuGet -  &lt;a href="https://www.nuget.org/packages/Cake.Bridge.DependencyInjection/"&gt;nuget.org/packages/Cake.Bridge.DependencyInjection&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>Utilize Cake abstractions and addins using Microsoft dependency injection</summary>
	</entry>
	<entry>
		<id>https://www.devlead.se/posts/2021/2021-01-11-blog-migrated-to-statiq</id>
		<title>Blog migrated to Statiq</title>
		<author>
			<name>devlead</name>
		</author>
		<link href="https://www.devlead.se/posts/2021/2021-01-11-blog-migrated-to-statiq" />
		<link rel="enclosure" type="image" href="https://cdn.devlead.se/clipimg-vscode/2021/01/11/a20c196d-ae40-ed83-1a49-ec09f0e55e2e.png?sv=2019-12-12&amp;st=2021-01-10T20%253A53%253A57Z&amp;se=2031-01-11T20%253A53%253A57Z&amp;sr=b&amp;sp=r&amp;sig=ZzDlx22k%252BmCJJkPeHnEcxZFZ5xbBoG4PQluscRG7%252BeM%253D" />
		<updated>2021-01-11T00:00:00Z</updated>
		<content>&lt;p&gt;Since 2016 I've been using Medium as my platform of choice, this is not a rage quit from the platform, I'll keep posting on Medium, the difference is that the main source for my posts will be on my own canonical domain, where I've got full access and control over my words.&lt;/p&gt;
&lt;p&gt;The decision is just as much that I've found a stack and toolchain I really like, feel comfortable, and hopefully productive with.&lt;/p&gt;
&lt;p&gt;The stack I've settled on has a few key components&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://statiq.dev/"&gt;Statiq Web&lt;/a&gt; - a brilliant .NET based static site generator by &lt;a href="https://daveaglick.com/"&gt;Dave Glick&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/"&gt;GitHub&lt;/a&gt; - where the code is stored.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://pages.github.com/"&gt;GitHub Pages&lt;/a&gt; - where the html is served from.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://azure.microsoft.com/en-us/services/cdn/"&gt;Azure CDN&lt;/a&gt; - where the blog images are served from.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://marketplace.visualstudio.com/items?itemName=gep13.clipimg-vscode"&gt;ClipImg&lt;/a&gt; - Visual Studio Code addin that takes images from clipboard, uploads to Azure blob storage and inserts the markdown needed to render image - with just one keyboard shortcut.&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>It was long overdue</summary>
	</entry>
</feed>