<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<id>https://www.devlead.se/</id>
	<title />
	<link rel="self" href="https://www.devlead.se/" />
	<rights>© Mattias Karlsson 2021</rights>
	<updated>2021-03-19T07:58:52Z</updated>
	<logo>https://cdn.devlead.se/clipimg-vscode/2021/01/11/1f2af322-a19f-753d-bd3e-00118dc674f1.png?sv=2019-12-12&amp;st=2021-01-10T15%253A16%253A48Z&amp;se=2031-01-11T15%253A16%253A48Z&amp;sr=b&amp;sp=r&amp;sig=RYHdZjTvO%252Fw0tUGsgnIiGJRhTiQQPHnEsSKtnV14Yoc%253D</logo>
	<entry>
		<id>https://www.devlead.se/posts/2021/2021-03-03-introducing-cake-clickonce-recipe</id>
		<title>Introducing Cake ClickOnce Recipe</title>
		<author>
			<name>devlead</name>
		</author>
		<link href="https://www.devlead.se/posts/2021/2021-03-03-introducing-cake-clickonce-recipe" />
		<link rel="enclosure" type="image" href="https://cdn.devlead.se/clipimg-vscode/2021/01/31/efaa9de4-9e5c-e66b-8b35-3f6b3475b8d3.png?sv=2019-12-12&amp;st=2021-01-30T15%253A03%253A52Z&amp;se=2031-01-31T15%253A03%253A52Z&amp;sr=b&amp;sp=r&amp;sig=wSUYJRdZjnHt0AZ86nc06YeF5eKqwXWAH%252F5525wyiAk%253D" />
		<updated>2021-03-03T00:00:00Z</updated>
		<content>&lt;p&gt;A little over a decade ago I did a lot of business applications with .NET Framework WPF and ClickOnce was in many cases used as a convenient way to deploy and update Windows applications. ClickOnce hasn't gotten much love over the years, and when .NET Core 3 introduced support for WPF applications ClickOnce support was nowhere to be found. But guess what, that's changed with .NET 5 and in this post, I'll go through my recipe for simplifying the building and publishing .NET 5 Windows application using GitHub Actions, Cake, and ClickOnce to Azure Blob Storage.&lt;/p&gt;
&lt;h2 id="cake-recipe"&gt;Cake Recipe?&lt;/h2&gt;
&lt;p&gt;So what is a Cake recipe? Regardless of what it sounds like, it in this case has nothing to do with baking, but it's a set of &lt;a href="https://cakebuild.net/"&gt;Cake&lt;/a&gt; scripts packaged as NuGet package and published on NuGet.org, providing a highly reusable way to with just a few lines of code get access to rich functionality.&lt;/p&gt;
&lt;p&gt;For example this recipe will for a .NET 5 based Windows application, in a very optioned way&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Version application&lt;/li&gt;
&lt;li&gt;Build application&lt;/li&gt;
&lt;li&gt;Create ClickOnce assets&lt;/li&gt;
&lt;li&gt;Deploy to Azure Blob storage&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="sample-application"&gt;Sample application&lt;/h2&gt;
&lt;p&gt;For simplicity I'm here going to use the standard .NET 5 WPF template, using .NET CLI that would look something like below&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet new wpf -n MyApp
dotnet new sln -n MyApp
dotnet sln add MyApp/MyApp.csproj
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which essentially:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Creates project&lt;/li&gt;
&lt;li&gt;Creates solution&lt;/li&gt;
&lt;li&gt;Adds project to solution&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Which is similar to &lt;em&gt;New Project -&amp;gt; WPF Application (C# / Windows / Desktop .NET Core)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/31/9348f210-84a6-74b2-5f9f-6f31e20b1877.png?sv=2019-12-12&amp;amp;st=2021-01-30T17%3A12%3A36Z&amp;amp;se=2031-01-31T17%3A12%3A36Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=YnOmvtwboOr30u0v1EnSsdpBpJnHl%2FcwEIKr9p%2FAQ1Y%3D" alt="Create new project in Visual Studio 2019" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/31/6dadc800-fcc0-31ab-f4f3-9446b5f5c411.png?sv=2019-12-12&amp;amp;st=2021-01-30T17%3A13%3A34Z&amp;amp;se=2031-01-31T17%3A13%3A34Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=jdfRM7ANfxT8XyzhzfXKZfv2U8JV%2B%2Bl%2BREX4ALUpdiM%3D" alt=".NET Core WPF Application Template" /&gt;&lt;/p&gt;
&lt;p&gt;Resulting in a bare minimum folder/file structure like below&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text"&gt;src
 │    MyApp.sln
 │
 └─── MyApp
        App.xaml
        App.xaml.cs
        AssemblyInfo.cs
        MainWindow.xaml
        MainWindow.xaml.cs
        MyApp.csproj
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="adding-cake.clickonce.recipe"&gt;Adding Cake.ClickOnce.Recipe&lt;/h2&gt;
&lt;p&gt;Now that we have our sample application, let's rub some DevOps on it using Cake.ClickOnce.Recipe.&lt;/p&gt;
&lt;h3 id="prerequisites"&gt;Prerequisites&lt;/h3&gt;
&lt;h4 id="tools"&gt;Tools&lt;/h4&gt;
&lt;p&gt;To run our recipe we need one .NET tool installed&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Cake.Tool 1.0.0 or newer&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;My preferred way is to install using a .NET tool manifest in repo root, so the tools are versioned and restored within the repo, a manifest is easiest created using the .NET CLI template &lt;code&gt;tool-manifest&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet new tool-manifest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and then install the tool&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet tool install Cake.Tool
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="azure"&gt;Azure&lt;/h4&gt;
&lt;p&gt;The recipe uses Azure Blob Storage to distribute the application and ClickOnce manifest, so you'll need to create:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Azure Storage Account&lt;/li&gt;
&lt;li&gt;Container with anonymous read access for blobs only&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/31/2afa2bbc-0d9a-7898-d056-d9a221d8dc1d.png?sv=2019-12-12&amp;amp;st=2021-01-30T20%3A42%3A16Z&amp;amp;se=2031-01-31T20%3A42%3A16Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=Kx6eIPJh9ZHdOvWEeP6GJl%2BChVgyrR21%2FO7qlEJ7us4%3D" alt="New Storage Collage" /&gt;&lt;/p&gt;
&lt;h3 id="adding-recipe"&gt;Adding recipe&lt;/h3&gt;
&lt;p&gt;In repo root create a &lt;code&gt;build.cake&lt;/code&gt; file containing&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;#load &amp;quot;nuget:?package=Cake.ClickOnce.Recipe&amp;amp;version=0.2.0&amp;quot;

ClickOnce.ApplicationName = &amp;quot;MyApp&amp;quot;;
ClickOnce.Publisher = &amp;quot;devlead&amp;quot;;
ClickOnce.PublishUrl = &amp;quot;https://cakeclickonceexample.blob.core.windows.net/publish&amp;quot;;
ClickOnce.RunBuild();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The Recipe has three required settings&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;ApplicationName&lt;/code&gt; - in general same as project name&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Publisher&lt;/code&gt; - name of publisher&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PublishUrl&lt;/code&gt; - base url for where application is installed from, in this case Azure Blob Storage container url&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="local-build"&gt;Local build&lt;/h2&gt;
&lt;p&gt;We're now all set to kick of a local build using Cake&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet cake
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and if all goes well you should see something like below&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text"&gt;Task                           Duration
---------------------------------------------------
Setup                          00:00:00.0070864
Clean                          00:00:00.0114975
Restore                        00:00:01.0136714
Build                          00:00:02.6537503
Publish                        00:00:00.9728737
ClickOnce-Launcher             00:00:00.3629962
ClickOnce-Application-Manifest 00:00:00.5536790
ClickOnce-Deployment-Manifest  00:00:00.5924181
---------------------------------------------------
Total:                         00:00:06.1730701
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and a new folder in repo root called artifacts containing application ClickOnce manifest and a date versioned folder (you can override the generated version using &lt;code&gt;ClickOnce.Version&lt;/code&gt; property).&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text"&gt;artifacts
 │   MyApp.application
 │
 └───MyApp.2021.01.31.25014
        Launcher.exe
        MyApp.deps.json
        MyApp.dll
        MyApp.exe
        MyApp.manifest
        MyApp.pdb
        MyApp.runtimeconfig.json
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="github-actions"&gt;GitHub Actions&lt;/h2&gt;
&lt;p&gt;A fairly minimal GitHub Actions could essentially be&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Checkout source&lt;/li&gt;
&lt;li&gt;Install .NET SDK&lt;/li&gt;
&lt;li&gt;Install &amp;amp; Execute Cake&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="build-definition"&gt;Build definition&lt;/h3&gt;
&lt;p&gt;The yaml build definition could look something like below&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;name: Build
on:
  pull_request:
  push:
    branches:
      - main
      - develop

jobs:
  build:
    name: Build
    runs-on: windows-latest
    steps:
      - name: Get the sources
        uses: actions/checkout&amp;#64;v2

      - name: Install .NET Core SDK
        uses: actions/setup-dotnet&amp;#64;v1

      - name: Run Cake script
        env:
          PUBLISH_STORAGE_ACCOUNT: ${{ secrets.PUBLISH_STORAGE_ACCOUNT }}
          PUBLISH_STORAGE_CONTAINER: ${{ secrets.PUBLISH_STORAGE_CONTAINER }}
          PUBLISH_STORAGE_KEY: ${{ secrets.PUBLISH_STORAGE_KEY }}
        run: |
          dotnet tool restore
          dotnet cake
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;Run Cake script&lt;/code&gt; step has three environment variables defined&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PUBLISH_STORAGE_ACCOUNT&lt;/code&gt; - Azure storage account name i.e. &lt;code&gt;cakeclickonceexample&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PUBLISH_STORAGE_CONTAINER&lt;/code&gt; - Azure storage container name i.e. &lt;code&gt;publish&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PUBLISH_STORAGE_KEY&lt;/code&gt; - Azure storage account secondary or primary key.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These are fetched from your GitHub repo settings Secrets section, which means they're not publicly stored anywhere in the repo and also not available from pull requests.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/03/02/8ebf213e-1f0d-8d68-d12d-58ceafe6d728.png?sv=2019-12-12&amp;amp;st=2021-03-01T21%3A51%3A01Z&amp;amp;se=2031-03-02T21%3A51%3A01Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=U%2BCyMGwq5x66LcKonxmi%2FjD52btWXph5Ku2P33T8rGE%3D" alt="GitHub Repo Secrets settings" /&gt;&lt;/p&gt;
&lt;h3 id="output-example-on-github-actions"&gt;Output Example on GitHub Actions&lt;/h3&gt;
&lt;p&gt;The recipe will automatically identify that it's executing on GitHub Actions, and execute a few extra steps to upload and point the ClickOnce manifest to the new version.&lt;/p&gt;
&lt;p&gt;If all goes well GitHub Actions output would look something like below&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;
----------------------------------------
Setup
----------------------------------------
Setting up version 2021.01.27.18139
▶ &amp;quot;Clean&amp;quot;
▶ &amp;quot;Restore&amp;quot;
▶ &amp;quot;Build&amp;quot;
▶ &amp;quot;Publish&amp;quot;
▶ &amp;quot;ClickOnce-Launcher&amp;quot;
▶ &amp;quot;ClickOnce-Application-Manifest&amp;quot;
▶ &amp;quot;ClickOnce-Deployment-Manifest&amp;quot;
▶ &amp;quot;ClickOnce-Deployment-UpdateManifest&amp;quot;
▶ &amp;quot;ClickOnce-Deployment-CreateAppRef&amp;quot;
▶ &amp;quot;ClickOnce-Upload-Version&amp;quot;
▶ &amp;quot;ClickOnce-Upload-Application&amp;quot;
▶ &amp;quot;Publish-ClickOnce&amp;quot;

Task                                Duration
--------------------------------------------------------
Setup                               00:00:00.0160939
Clean                               00:00:00.0084806
Restore                             00:00:02.1274733
Build                               00:00:03.3076849
Publish                             00:00:01.2192429
ClickOnce-Launcher                  00:00:00.4506914
ClickOnce-Application-Manifest      00:00:00.6510728
ClickOnce-Deployment-Manifest       00:00:00.9086913
ClickOnce-Deployment-UpdateManifest 00:00:00.6800874
ClickOnce-Deployment-CreateAppRef   00:00:00.0112772
ClickOnce-Upload-Version            00:00:02.1736495
ClickOnce-Upload-Application        00:00:00.6269294
--------------------------------------------------------
Total:                              00:00:12.1814083
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and you now have a fully automated build and release of your ClickOnce application.&lt;/p&gt;
&lt;h2 id="installing-application"&gt;Installing application&lt;/h2&gt;
&lt;p&gt;The recipe will automatically generate an &lt;code&gt;appref-ms&lt;/code&gt; file, downloading and opening this file from blob storage is enough to trigger the ClickOnce runtime and install the application.&lt;/p&gt;
&lt;p&gt;Example: &lt;a href="https://cakeclickonceexample.blob.core.windows.net/publish/MyApp.appref-ms"&gt;cakeclickonceexample.blob.core.windows.net/publish/MyApp.appref-ms&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/03/02/installclickonce.gif?sp=r&amp;amp;st=2021-03-01T23:03:03Z&amp;amp;se=2031-03-03T07:03:03Z&amp;amp;spr=https&amp;amp;sv=2020-02-10&amp;amp;sr=b&amp;amp;sig=hSBI7hfdtkWR0SqdX5yiHDeE9E%2FwZzWCEHTZqp518Ls%3D" alt="ClickOnce installation example" /&gt;&lt;/p&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Long story short, the recipe greatly simplifies the automation of building a WPF application, getting it published and deployed using ClickOnce technologies - achieving this only configuring the bare minimum what's needed to do so.&lt;/p&gt;
&lt;p&gt;There's still a lot of work to do with the recipe especially around signing, icons, etc.&lt;/p&gt;
&lt;p&gt;That said it's fully functional and a good starting point.
The recipe is open source, so I'll happily take feedback and contributions to improve it.&lt;/p&gt;
&lt;h2 id="resources"&gt;Resources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Recipe source on GitHub - &lt;a href="https://github.com/devlead/Cake.ClickOnce.Recipe"&gt;github.com/devlead/Cake.ClickOnce.Recipe&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Recipe on NuGet.org - &lt;a href="https://www.nuget.org/packages/Cake.ClickOnce.Recipe/"&gt;nuget.org/packages/Cake.ClickOnce.Recipe&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Example repository on GitHub - &lt;a href="https://github.com/devlead/Cake.ClickOnce.Recipe.Example"&gt;github.com/devlead/Cake.ClickOnce.Recipe.Example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Cake - &lt;a href="https://cakebuild.net/"&gt;cakebuild.net&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>An opinionated recipe for building and publishing .NET 5 Windows apps</summary>
	</entry>
	<entry>
		<id>https://www.devlead.se/posts/2021/2021-01-15-my-preferred-console-stack</id>
		<title>My preferred .NET console stack</title>
		<author>
			<name>devlead</name>
		</author>
		<link href="https://www.devlead.se/posts/2021/2021-01-15-my-preferred-console-stack" />
		<link rel="enclosure" type="image" href="https://cdn.devlead.se/clipimg-vscode/2021/01/14/e02ce155-5ff2-8a7b-e306-8c486f23f864.png?sv=2019-12-12&amp;st=2021-01-13T20%253A33%253A10Z&amp;se=2031-01-14T20%253A33%253A10Z&amp;sr=b&amp;sp=r&amp;sig=fdANWdytZGRdgDMxN%252B%252BTNSCAbz%252Bzg6R0iAvtvYWYoKw%253D" />
		<updated>2021-01-15T00:00:00Z</updated>
		<content>&lt;p&gt;There's type of application that has followed me since I learned to code in the mid-'80s, and that's the console application. For years they looked the same a &lt;code&gt;Main(string[] args)&lt;/code&gt; and some naive inconsistent command line parser. That gradually improved with the adoption of various OSS helper libraries. In this post, I'll walk through what today is my alternative starting point to &lt;code&gt;dotnet new console&lt;/code&gt;, a way that greatly reduces the boilerplate code needed for logging, parsing, and validation of arguments, letting me focus on the problem to solve and not the plumbing.&lt;/p&gt;
&lt;h2 id="templates"&gt;Templates&lt;/h2&gt;
&lt;p&gt;A convenient way to scaffold a new project is using the template function of .NET SDK CLI, it comes preloaded with several templates like &lt;code&gt;console&lt;/code&gt;, &lt;code&gt;classlib&lt;/code&gt;, etc., but beyond that, it's possible to create your own templates, which I've for my and your convenience created, so given &lt;a href="https://dotnet.microsoft.com/download/dotnet/5.0"&gt;.NET 5 SDK&lt;/a&gt; installed, easily yourself can try and take a look at everything discussed in this post.&lt;/p&gt;
&lt;h2 id="devlead-console-template"&gt;Devlead Console Template&lt;/h2&gt;
&lt;p&gt;So let's get started with creating a new console application according to my opinionated recipe, .NET SDK Templates are distributed as NuGet packages and the canonical source for NuGet packages is &lt;a href="https://www.nuget.org"&gt;NuGet.org&lt;/a&gt;, where I've published my template as &lt;a href="https://www.nuget.org/packages/Devlead.Console.Template/"&gt;Devlead.Console.Template&lt;/a&gt;. Templates are installed using the &lt;code&gt;dotnet new&lt;/code&gt; command with &lt;code&gt;--install packageId&lt;/code&gt; parameter, in this case:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet new --install Devlead.Console.Template
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="dotnet-new-devleadconsole"&gt;dotnet new devleadconsole&lt;/h2&gt;
&lt;p&gt;With the template installed locally, we now have a new &lt;code&gt;devleadconsole&lt;/code&gt; template at our disposal, to create our new console applications with according to me, essential dependencies and boilerplate code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet new devleadconsole -n MyConsoleApp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above command will in the current directory result in the below folder structure&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text"&gt;MyConsoleApp
    │   MyConsoleApp.csproj
    │   Program.cs
    │
    └───Commands
        │   ConsoleCommand.cs
        │
        ├───Settings
        │       ConsoleSettings.cs
        │
        └───Validation
                ValidateStringAttribute.cs
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="myconsoleapp.csproj"&gt;MyConsoleApp.csproj&lt;/h2&gt;
&lt;p&gt;The created project file will look something like below&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;Project Sdk=&amp;quot;Microsoft.NET.Sdk&amp;quot;&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt;
    &amp;lt;TargetFramework&amp;gt;net5.0&amp;lt;/TargetFramework&amp;gt;
    &amp;lt;Nullable&amp;gt;enable&amp;lt;/Nullable&amp;gt;
    &amp;lt;TreatWarningsAsErrors&amp;gt;true&amp;lt;/TreatWarningsAsErrors&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Spectre.Console&amp;quot; Version=&amp;quot;0.37.0&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Spectre.Cli.Extensions.DependencyInjection&amp;quot; Version=&amp;quot;0.3.0&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.Extensions.Logging&amp;quot; Version=&amp;quot;5.0.0&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.Extensions.Logging.Console&amp;quot; Version=&amp;quot;5.0.0&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.SourceLink.GitHub&amp;quot; Version=&amp;quot;1.0.0&amp;quot; PrivateAssets=&amp;quot;All&amp;quot;/&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;let's step for step break it down&lt;/p&gt;
&lt;h3 id="outputtype"&gt;OutputType&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;OutputType&lt;/code&gt; with the value &lt;code&gt;exe&lt;/code&gt;, indicates that this will be an executable.&lt;/p&gt;
&lt;h3 id="targetframework"&gt;TargetFramework&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;TargetFramework&lt;/code&gt; with the value &lt;code&gt;net5.0&lt;/code&gt;, means that this will be compiled for/targeting .NET 5.&lt;/p&gt;
&lt;h3 id="nullable"&gt;Nullable&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Nullable&lt;/code&gt; with the value &lt;code&gt;enable&lt;/code&gt;, enables the &lt;a href="https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references"&gt;nullable reference types&lt;/a&gt; feature that was introduced with C# 8, making reference types non-nullable by default, basically moving many errors from being caught late at runtime, to be caught early at compile time.&lt;/p&gt;
&lt;h3 id="treatwarningsaserrors"&gt;TreatWarningsAsErrors&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;TreatWarningsAsErrors&lt;/code&gt; with the value &lt;code&gt;true&lt;/code&gt; makes the compiler grumpier, it won't just break the build for compiler errors, but also for compiler warnings, combined with &lt;code&gt;Nullable&lt;/code&gt; I personally believe code quality gets better from the start.&lt;/p&gt;
&lt;h3 id="packagereferences"&gt;PackageReference(s)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://www.nuget.org/packages/Spectre.Console"&gt;Spectre.Console&lt;/a&gt;&lt;/strong&gt; is a lot of things, a true swiss army for anyone doing console applications, but in this template, it's foremost an extremely opinionated command-line parser.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://www.nuget.org/packages/Spectre.Cli.Extensions.DependencyInjection"&gt;Spectre.Cli.Extensions.DependencyInjection&lt;/a&gt;&lt;/strong&gt; makes it easy for &lt;a href="https://www.nuget.org/packages/Spectre.Console"&gt;Spectre.Console&lt;/a&gt; to interop with standard &lt;strong&gt;&lt;a href="https://www.nuget.org/packages/Microsoft.Extensions.DependencyInjection/"&gt;Microsoft DependencyInjection&lt;/a&gt;&lt;/strong&gt;, same as used by default for dependency injection with i.e. ASP .NET and Azure Functions.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://www.nuget.org/packages/Microsoft.Extensions.Logging"&gt;Microsoft.Extensions.Logging&lt;/a&gt;&lt;/strong&gt; simplified provides standard logging abstractions and &lt;strong&gt;&lt;a href="https://www.nuget.org/packages/Microsoft.Extensions.Logging.Console"&gt;Microsoft.Extensions.Logging.Console&lt;/a&gt;&lt;/strong&gt; provides an implementation for logging to the console.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://www.nuget.org/packages/Microsoft.SourceLink.GitHub"&gt;Microsoft.SourceLink.GitHub&lt;/a&gt;&lt;/strong&gt; enables automatic tracking between artifact and source control, providing a better debugging and traceability experience.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="program.cs"&gt;Program.cs&lt;/h2&gt;
&lt;p&gt;The generated &lt;code&gt;Program.cs&lt;/code&gt; uses the new C#9 &lt;a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9#top-level-statements"&gt;Top-level statement&lt;/a&gt; pattern removing unnecessary ceremony code from the application, but what it does contain:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;using statements&lt;/li&gt;
&lt;li&gt;Creating dependency injection container&lt;/li&gt;
&lt;li&gt;Console logger registration&lt;/li&gt;
&lt;li&gt;Hooking up dependency injection container with Spectre.Console&lt;/li&gt;
&lt;li&gt;Spectre.Console command declaration&lt;/li&gt;
&lt;li&gt;Execute the application&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;Note: &lt;a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9#top-level-statements"&gt;Top-level statement&lt;/a&gt;  means as &lt;code&gt;RunAsync&lt;/code&gt; returns a &lt;code&gt;Task&amp;lt;int&amp;gt;&lt;/code&gt;, .NET 5 will automatically generate &amp;quot;&lt;code&gt;Program&lt;/code&gt;&amp;quot; class and &lt;code&gt;async Task&amp;lt;int&amp;gt; Main(string args)&lt;/code&gt; for you, removing the need to write a lot of boilerplate code.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Devlead.Console.Commands;
using Spectre.Console.Cli;
using Spectre.Cli.Extensions.DependencyInjection;

var serviceCollection = new ServiceCollection()
    .AddLogging(configure =&amp;gt;
            configure
                .AddSimpleConsole(opts =&amp;gt; {
                    opts.TimestampFormat = &amp;quot;yyyy-MM-dd HH:mm:ss &amp;quot;;
                })
    );

using var registrar = new DependencyInjectionRegistrar(serviceCollection);
var app = new CommandApp(registrar);

app.Configure(
    config =&amp;gt;
    {
        config.ValidateExamples();

        config.AddCommand&amp;lt;ConsoleCommand&amp;gt;(&amp;quot;console&amp;quot;)
                .WithDescription(&amp;quot;Example console command.&amp;quot;)
                .WithExample(new[] { &amp;quot;console&amp;quot; });
    });

return await app.RunAsync(args);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="consolecommand.cs"&gt;ConsoleCommand.cs&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ConsoleCommand.cs&lt;/code&gt; contains &amp;quot;just&amp;quot; your business code, &lt;a href="https://spectresystems.github.io/spectre.console/"&gt;Spectre.Console&lt;/a&gt; handles the heavy lifting of parsing and validating command-line arguments (&lt;em&gt;based on provided settings class, more on that later in the post.&lt;/em&gt;), resolving constructor parameters using dependency injection, etc. Letting you focus on the domain and not the boilerplate code, resulting in a very similar experience to i.e. Azure Function or .NET Workers, enabling reuse of both patterns and code. &lt;a href="https://spectresystems.github.io/spectre.console/"&gt;Spectre.Console&lt;/a&gt; has support for both async and sync commands.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using MyConsoleApp.Commands.Setting;
using Spectre.Console.Cli;

namespace MyConsoleApp.Commands
{
    public class ConsoleCommand : AsyncCommand&amp;lt;ConsoleSettings&amp;gt;
    {
        private ILogger Logger { get; }

        public override async Task&amp;lt;int&amp;gt; ExecuteAsync(CommandContext context, ConsoleSettings settings)
        {
            Logger.LogInformation(&amp;quot;Mandatory: {Mandatory}&amp;quot;, settings.Mandatory);
            Logger.LogInformation(&amp;quot;Optional: {Optional}&amp;quot;, settings.Optional);
            Logger.LogInformation(&amp;quot;CommandOptionFlag: {CommandOptionFlag}&amp;quot;, settings.CommandOptionFlag);
            Logger.LogInformation(&amp;quot;CommandOptionValue: {CommandOptionValue}&amp;quot;, settings.CommandOptionValue);
            return await Task.FromResult(0);
        }

        public ConsoleCommand(ILogger&amp;lt;ConsoleCommand&amp;gt; logger)
        {
            Logger = logger;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="consolesettings.cs"&gt;ConsoleSettings.cs&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ConsoleSettings.cs&lt;/code&gt; contains the definition of what parameters each command has, if they're are mandatory/optional, positional and how they validated. It also contains metadata used for automatically generating help and error messages.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using System.ComponentModel;
using Devlead.Console.Commands.Validate;
using Spectre.Console.Cli;

namespace Devlead.Console.Commands.Setting
{
    public class ConsoleSettings : CommandSettings
    {
        [CommandArgument(0, &amp;quot;&amp;lt;mandatory&amp;gt;&amp;quot;)]
        [Description(&amp;quot;Mandatory argument&amp;quot;)]
        public string Mandatory { get; set; } = string.Empty;

        [CommandArgument(1, &amp;quot;[optional]&amp;quot;)]
        [Description(&amp;quot;Optional argument&amp;quot;)]
        public string? Optional { get; set; }

        [CommandOption(&amp;quot;--command-option-flag&amp;quot;)]
        [Description(&amp;quot;Command option flag.&amp;quot;)]
        public bool CommandOptionFlag { get; set; }

        [CommandOption(&amp;quot;--command-option-value &amp;lt;value&amp;gt;&amp;quot;)]
        [Description(&amp;quot;Command option value.&amp;quot;)]
        [ValidateString]
        public string? CommandOptionValue { get; set; }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="validatestringattribute.cs"&gt;ValidateStringAttribute.cs&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://spectresystems.github.io/spectre.console/"&gt;Spectre.Console&lt;/a&gt; can validate either by custom attributes on properties (&lt;em&gt;see &lt;code&gt;ConsoleSettings.CommandOptionValue&lt;/code&gt; for an example of that&lt;/em&gt;) or globally by overriding &lt;code&gt;Validate()&lt;/code&gt; method on &lt;code&gt;CommandSettings&lt;/code&gt;. The template ships with a sample &lt;code&gt;ValidateStringAttribute&lt;/code&gt; that just validates the length of a string, but you can make it as advanced as you want.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using Spectre.Console;
using Spectre.Console.Cli;

namespace MyConsoleApp.Commands.Validation
{
    public class ValidateStringAttribute : ParameterValidationAttribute
    {
        public const int MinimumLength = 3;

        public ValidateStringAttribute() : base(errorMessage: null)
        {
        }

        public override ValidationResult Validate(ICommandParameterInfo parameterInfo, object? value)
            =&amp;gt; (value as string) switch {
                { Length: &amp;gt;= MinimumLength }
                    =&amp;gt; ValidationResult.Success(),

                { Length: &amp;lt; MinimumLength }
                    =&amp;gt; ValidationResult.Error($&amp;quot;{parameterInfo?.PropertyName} ({value}) needs to be at least {MinimumLength} characters long.&amp;quot;),

                _ =&amp;gt; ValidationResult.Error($&amp;quot;Invalid {parameterInfo?.PropertyName} ({value}) specified.&amp;quot;)
            };
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="result"&gt;Result&lt;/h2&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/15/devleadmyconsoleapp.gif?sp=rl&amp;amp;st=2021-01-15T09:33:29Z&amp;amp;se=2031-01-16T09:33:00Z&amp;amp;sv=2019-12-12&amp;amp;sr=b&amp;amp;sig=fp8lXgfDwOgGkdK3cYm0fFojddT8ZEx7SJuiIMkIOW8%3D" alt="GIF animation of Console experience" /&gt;&lt;/p&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;This is my opinionated happy path for doing .NET Console applications, feel free to let me know if you've got your own recipe for success, but must say I'm really happy how this combination lets me write console applications in the same way as I do my .NET workers, Azure Functions, ASP .NET Core, etc. ensuring consistency, less duplication and good reuse of both patterns and code. There's a LOT more to &lt;a href="https://spectresystems.github.io/spectre.console/"&gt;Spectre.Console&lt;/a&gt; than command-line parsing, to I hight recommend you check out all the other features it has to offer.&lt;/p&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/devlead/Devlead.Console.Template"&gt;Devlead.Console.Template&lt;/a&gt; (&lt;a href="https://www.nuget.org/packages/Devlead.Console.Template"&gt;NuGet&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://spectresystems.github.io/spectre.console/"&gt;Spectre.Console&lt;/a&gt; (&lt;a href="https://www.nuget.org/packages/Spectre.Console"&gt;NuGet&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/agc93/spectre.cli.extensions.dependencyinjection#spectrecliextensionsdependencyinjection"&gt;Spectre.Cli.Extensions.DependencyInjection&lt;/a&gt; (&lt;a href="https://www.nuget.org/packages/Spectre.Cli.Extensions.DependencyInjection"&gt;NuGet&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-5.0"&gt;Dependency injection in ASP.NET Core&lt;/a&gt; (&lt;a href="https://www.nuget.org/packages/Microsoft.Extensions.DependencyInjection/"&gt;NuGet&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/sourcelink#source-link"&gt;Source Link&lt;/a&gt; (&lt;a href="https://www.nuget.org/packages/Microsoft.SourceLink.GitHub"&gt;NuGet&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-5.0"&gt;Logging in .NET Core and ASP.NET Core&lt;/a&gt; (&lt;a href="https://www.nuget.org/packages/Microsoft.Extensions.Logging.Console"&gt;NuGet&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>An opinionated view on the boilerplate starting point of any .NET console application</summary>
	</entry>
	<entry>
		<id>https://www.devlead.se/posts/2021/2021-01-12-introducing-cake-bridge-dependency-injection</id>
		<title>Introducing Cake Bridge Dependency Injection</title>
		<author>
			<name>devlead</name>
		</author>
		<link href="https://www.devlead.se/posts/2021/2021-01-12-introducing-cake-bridge-dependency-injection" />
		<link rel="enclosure" type="image" href="https://cdn.devlead.se/clipimg-vscode/2021/01/12/c2a643e9-2c63-361b-b458-a647352ebe87.png?sv=2019-12-12&amp;st=2021-01-11T10%253A13%253A57Z&amp;se=2031-01-12T10%253A13%253A57Z&amp;sr=b&amp;sp=r&amp;sig=qInj%252F3o1X2jmpZR1KQIWUgaYF5S8c9zJz0l7zZVYmWg%253D" />
		<updated>2021-01-12T00:00:00Z</updated>
		<content>&lt;p&gt;A couple of years ago I blogged &lt;a href="https://www.devlead.se/posts/2017/2017-07-09-dispelling-the-magic"&gt;Dispelling the magic!&lt;/a&gt;, a post explaining the internals of the &lt;a href="https://cakebuild.net"&gt;Cake&lt;/a&gt; build orchestration tool, with that post as a proof of concept I created &lt;a href="https://www.nuget.org/packages/Cake.Bridge"&gt;Cake.Bridge&lt;/a&gt; assembly which provided an easy way from any .NET language get access to Cake abstractions and addins from a single instance static class.&lt;/p&gt;
&lt;h2 id="the-need"&gt;The Need&lt;/h2&gt;
&lt;p&gt;Cake has some real nice testable abstractions around working with the filesystem, processes, tools, etc. and for a .NET project, we had just that need. But a static instance isn't very testable, and for most of our .NET projects (console apps, APIs, Azure Functions, WPF, etc.) we now use dependency injection using &lt;a href="https://www.nuget.org/packages/Microsoft.Extensions.DependencyInjection/"&gt;Microsoft.Extensions.DependencyInjection&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;So with that in mind, I created an extension method to &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.iservicecollection?view=dotnet-plat-ext-5.0"&gt;IServiceCollection&lt;/a&gt; that easily provided me a way to get a &lt;a href="https://cakebuild.net/api/Cake.Core.IO/IFileSystem/"&gt;IFileSystem&lt;/a&gt; injected and utilizing the &lt;a href="https://cakebuild.net/api/Cake.Testing/FakeFileSystem/"&gt;FakeFileSystem&lt;/a&gt; provided by &lt;a href="https://www.nuget.org/packages/Cake.Testing"&gt;Cake.Testing&lt;/a&gt; for testing.
That grew into supporting most core Cake types including the more complex &lt;a href="https://cakebuild.net/api/Cake.Core/ICakeContext/"&gt;ICakeContext&lt;/a&gt; and &lt;a href="https://cakebuild.net/api/Cake.Core.Scripting/IScriptHost/"&gt;IScriptHost&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="introducing-cake.bridge.dependencyinjection"&gt;Introducing Cake.Bridge.DependencyInjection&lt;/h2&gt;
&lt;p&gt;If we got a need, chances are someone else has it too, so I've open-sourced the code and made it available as a NuGet &lt;a href="https://www.nuget.org/packages/Cake.Bridge.DependencyInjection/"&gt;package&lt;/a&gt;. It's early bits tailored for a specific need, so you should expect some rough edges, but sharing is caring.&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;h3 id="obtain"&gt;Obtain&lt;/h3&gt;
&lt;p&gt;The assembly is published at &lt;a href="https://www.nuget.org/packages/Cake.Bridge.DependencyInjection"&gt;NuGet.org/packages/Cake.Bridge.DependencyInjection&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id="net-cli"&gt;.NET CLI&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet add package Cake.Bridge.DependencyInjection
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="packagereference"&gt;PackageReference&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;PackageReference Include="Cake.Bridge.DependencyInjection" Version="0.1.0" /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="register"&gt;Register&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using Cake.Bridge.DependencyInjection;
...
serviceCollection
    .AddCakeCore();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="resolve"&gt;Resolve&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using Cake.Core;
...
var cakeContext = serviceProvider.GetRequiredService&amp;lt;ICakeContext&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="use"&gt;Use&lt;/h3&gt;
&lt;p&gt;Once registered you can now via dependency injection access the majority &lt;a href="https://cakebuild.net/api/Cake.Core/#InterfaceTypes"&gt;Cake.Core&lt;/a&gt; interfaces with ease, i.e:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://cakebuild.net/api/Cake.Core/ICakeContext/"&gt;ICakeContext&lt;/a&gt; - Gives access to Cake built-in and addin aliases, and most Cake abstractions.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://cakebuild.net/api/Cake.Core.Scripting/IScriptHost/"&gt;IScriptHost&lt;/a&gt; - Gives access to script/task runner.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://cakebuild.net/api/Cake.Core.Diagnostics/ICakeLog/"&gt;ICakeLog&lt;/a&gt; - Cake logging implementation.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://cakebuild.net/api/Cake.Core.IO/IFileSystem/"&gt;IFileSystem&lt;/a&gt; - Cake file system abstraction.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="example-icakecontext"&gt;Example ICakeContext&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using Cake.Bridge.DependencyInjection;
using Cake.Core;
using Cake.Core.Diagnostics;
using Microsoft.Extensions.DependencyInjection;

var serviceCollection = new ServiceCollection()
    .AddCakeCore();

var serviceProvider = serviceCollection.BuildServiceProvider();

var cakeContext = serviceProvider.GetRequiredService&amp;lt;ICakeContext&amp;gt;();

cakeContext.Log.Write(
    Verbosity.Normal,
    LogLevel.Information,
    "Hello World!");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;will output&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;Hello World!
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="example-iscripthost-and-cake.common"&gt;Example IScriptHost and Cake.Common&lt;/h3&gt;
&lt;p&gt;Cake.Common contains Cake aliases normally ships together with the Cake script runner, when using Cake Bridge you'll need to add it to you project (same for any Cake addin).&lt;/p&gt;
&lt;h4 id="net-cli-1"&gt;.NET CLI&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet add package Cake.Common --version 1.0.0-rc0002
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="packagereference-1"&gt;PackageReference&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;PackageReference Include="Cake.Common" Version="1.0.0-rc0002" /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;then add the appropriate using statements and you can achieve something very similar to a Cake "script"&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using Cake.Bridge.DependencyInjection;
using Cake.Core;
using Cake.Common.Diagnostics;
using Cake.Core.Scripting;
using Microsoft.Extensions.DependencyInjection;

var serviceCollection = new ServiceCollection()
    .AddCakeCore();

var serviceProvider = serviceCollection.BuildServiceProvider();

var scriptHost = serviceProvider.GetRequiredService&amp;lt;IScriptHost&amp;gt;();

scriptHost.Task("Hello")
    .Does(ctx =&amp;gt; ctx.Information("Hello"));

scriptHost.Task("World")
    .IsDependentOn("Hello")
    .Does(ctx =&amp;gt; ctx.Information("World"));

await scriptHost.RunTargetAsync("World");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;will output&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;========================================
Hello
========================================
Hello

========================================
World
========================================
World

Task                          Duration
--------------------------------------------------
Hello                         00:00:00.0226275
World                         00:00:00.0002682
--------------------------------------------------
Total:                        00:00:00.0228957
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="complete-example-project"&gt;Complete example project&lt;/h3&gt;
&lt;p&gt;A full example console application using &lt;a href="https://www.nuget.org/packages/Spectre.Console"&gt;Spectre.Console&lt;/a&gt; demonstrating usage of both &lt;a href="https://cakebuild.net/api/Cake.Core/ICakeContext/"&gt;ICakeContext&lt;/a&gt; and &lt;a href="https://cakebuild.net/api/Cake.Core.Scripting/IScriptHost/"&gt;IScriptHost&lt;/a&gt; can be found in project's GitHub &lt;a href="https://github.com/devlead/Cake.Bridge.DependencyInjection"&gt;repository&lt;/a&gt; at &lt;a href="https://github.com/devlead/Cake.Bridge.DependencyInjection/tree/develop/src/Cake.Bridge.DependencyInjection.Example"&gt;src/Cake.Bridge.DependencyInjection.Example&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="resources"&gt;Resources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;GitHub - &lt;a href="https://github.com/devlead/Cake.Bridge.DependencyInjection"&gt;github.com/devlead/Cake.Bridge.DependencyInjection&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;NuGet -  &lt;a href="https://www.nuget.org/packages/Cake.Bridge.DependencyInjection/"&gt;nuget.org/packages/Cake.Bridge.DependencyInjection&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>Utilize Cake abstractions and addins using Microsoft dependency injection</summary>
	</entry>
	<entry>
		<id>https://www.devlead.se/posts/2021/2021-01-11-blog-migrated-to-statiq</id>
		<title>Blog migrated to Statiq</title>
		<author>
			<name>devlead</name>
		</author>
		<link href="https://www.devlead.se/posts/2021/2021-01-11-blog-migrated-to-statiq" />
		<link rel="enclosure" type="image" href="https://cdn.devlead.se/clipimg-vscode/2021/01/11/a20c196d-ae40-ed83-1a49-ec09f0e55e2e.png?sv=2019-12-12&amp;st=2021-01-10T20%253A53%253A57Z&amp;se=2031-01-11T20%253A53%253A57Z&amp;sr=b&amp;sp=r&amp;sig=ZzDlx22k%252BmCJJkPeHnEcxZFZ5xbBoG4PQluscRG7%252BeM%253D" />
		<updated>2021-01-11T00:00:00Z</updated>
		<content>&lt;p&gt;Since 2016 I've been using Medium as my platform of choice, this is not a rage quit from the platform, I'll keep posting on Medium, the difference is that the main source for my posts will be on my own canonical domain, where I've got full access and control over my words.&lt;/p&gt;
&lt;p&gt;The decision is just as much that I've found a stack and toolchain I really like, feel comfortable, and hopefully productive with.&lt;/p&gt;
&lt;p&gt;The stack I've settled on has a few key components&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://statiq.dev/"&gt;Statiq Web&lt;/a&gt; - a brilliant .NET based static site generator by &lt;a href="https://daveaglick.com/"&gt;Dave Glick&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/"&gt;GitHub&lt;/a&gt; - where the code is stored.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://pages.github.com/"&gt;GitHub Pages&lt;/a&gt; - where the html is served from.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://azure.microsoft.com/en-us/services/cdn/"&gt;Azure CDN&lt;/a&gt; - where the blog images are served from.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://marketplace.visualstudio.com/items?itemName=gep13.clipimg-vscode"&gt;ClipImg&lt;/a&gt; - Visual Studio Code addin that takes images from clipboard, uploads to Azure blob storage and inserts the markdown needed to render image - with just one keyboard shortcut.&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>It was long overdue</summary>
	</entry>
	<entry>
		<id>https://www.devlead.se/posts/2019/2019-12-06-just-an-environment-variable-away-from-sleep</id>
		<title>Just an environment variable away from sleep</title>
		<author>
			<name>devlead</name>
		</author>
		<link href="https://www.devlead.se/posts/2019/2019-12-06-just-an-environment-variable-away-from-sleep" />
		<link rel="enclosure" type="image" href="https://cdn.devlead.se/clipimg-vscode/2021/01/11/1f2af322-a19f-753d-bd3e-00118dc674f1.png?sv=2019-12-12&amp;st=2021-01-10T15%253A16%253A48Z&amp;se=2031-01-11T15%253A16%253A48Z&amp;sr=b&amp;sp=r&amp;sig=RYHdZjTvO%252Fw0tUGsgnIiGJRhTiQQPHnEsSKtnV14Yoc%253D" />
		<updated>2019-12-06T00:00:00Z</updated>
		<content>&lt;p&gt;It’s a quarter past midnight, you should be going to sleep, but there’s that one unit test that fails only on GitHub Action macOS build agent — it’s mocking you so you stay awake just a bit longer…&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/11/002a2a50-81cb-491e-145e-bc8ef7ceb2bd.png?sv=2019-12-12&amp;amp;st=2021-01-10T09%3A13%3A54Z&amp;amp;se=2031-01-11T09%3A13%3A54Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=QDRIJM%2FTAGDrRbSk7zA%2FrdfRBNBxhZoIZuIkrmbWEQg%3D" alt="Failed MacOS build on GitHub PR" /&gt;&lt;/p&gt;
&lt;p&gt;You bring out you Mac and execute tests, fortunately we can reproduce — the test fails on your machine too! A quick inspection of test output informs you that error only occurs on .NET Core.&lt;/p&gt;
&lt;p&gt;Unfortunately, today neither VS Mac nor VSCode for some reason is your friend, solutions won’t build, tests aren’t found, break points aren’t hit and so on.&lt;/p&gt;
&lt;p&gt;Probably not their fault at all, more likely a case of complex multi target solution, having preview versions and just being too tired.&lt;/p&gt;
&lt;p&gt;Fortunately, as the .NET CLI “dotnet test” command executed by the build script compiled and executed the tests, one could leave the VS Mac/Code IDE tooling debugging for another day and trigger debugging from the command line.&lt;/p&gt;
&lt;p&gt;This is achieved by setting the environment variable &lt;code&gt;VSTEST_HOST_DEBUG&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id="bash"&gt;Bash&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;export VSTEST_HOST_DEBUG=1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="powershell"&gt;PowerShell&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;$env:VSTEST_HOST_DEBUG=1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now when executing the test (specifying only the framework I want to test)&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet test My.Tests.csproj —-framework=netcoreapp3.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It’ll will pause and wait for a debugger to attach.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;Microsoft (R) Test Execution Command Line Tool Version 16.3.0
Copyright (c) Microsoft Corporation.  All rights reserved.Starting test execution, please wait...A total of 1 test files matched the specified pattern.
Host debugging is enabled. Please attach debugger to testhost process to continue.
Process Id: 32723, Name: dotnet
Waiting for debugger attach…
Process Id: 32723, Name: dotnet
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/11/3f6c41b2-be6d-1259-483f-0cb610799074.png?sv=2019-12-12&amp;amp;st=2021-01-10T09%3A45%3A48Z&amp;amp;se=2031-01-11T09%3A45%3A48Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=OtBMnkTPJeuR93Eh9vo8MSGB5SwUiRnSH6UOw3WN4HY%3D" alt="Attach to Process in VSMac" /&gt;&lt;/p&gt;
&lt;p&gt;and VS Code&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/11/0d7a04ed-add1-3db6-6c14-55e0e733ce9f.png?sv=2019-12-12&amp;amp;st=2021-01-10T09%3A46%3A29Z&amp;amp;se=2031-01-11T09%3A46%3A29Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=NnZf%2Fdn1BQLaaj4Wos2%2Bn9QMDc4WLXK5AN8K6Cj8swo%3D" alt="Attach to Process VSCode" /&gt;&lt;/p&gt;
&lt;p&gt;Which allowed me to set break points, inspect variables and step through code, even though the IDEs themselves for some reason couldn’t compile and execute the tests.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/11/fa197436-9d59-63e7-00dc-795b2df63c12.png?sv=2019-12-12&amp;amp;st=2021-01-10T09%3A47%3A13Z&amp;amp;se=2031-01-11T09%3A47%3A13Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=W2frMVBD%2Bs4IH8a%2FCyPas4Aw2yVpzfzhF9%2FpXUT1VF0%3D" alt="IDE test break points hit" /&gt;&lt;/p&gt;
&lt;p&gt;Fairly quickly found the issue added a commit and builds were green and I could go to sleep.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/11/f94d4dea-7f34-2d6b-2b98-b78a727ebe35.png?sv=2019-12-12&amp;amp;st=2021-01-10T09%3A47%3A48Z&amp;amp;se=2031-01-11T09%3A47%3A48Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=tgplc9XhXuY5qBJLd%2FCSU4ZUKaz%2BgorxGG%2B9h0%2F2C60%3D" alt="macOS build passes" /&gt;&lt;/p&gt;
&lt;p&gt;Sometimes you just want to attack the problem and not debug tooling, then attacking the problem from another direction might get you there quicker, today it was setting &lt;code&gt;VSTEST_HOST_DEBUG&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;
</content>
		<summary>&lt;p&gt;It’s a quarter past midnight, you should be going to sleep, but there’s that one unit test that fails only on GitHub Action macOS build agent — it’s mocking you so you stay awake just a bit longer…&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://www.devlead.se/posts/2018/2018-06-03-cake.kudu.client-version-0.6.0-released</id>
		<title>Cake.Kudu.Client version 0.6.0 released</title>
		<author>
			<name>devlead</name>
		</author>
		<link href="https://www.devlead.se/posts/2018/2018-06-03-cake.kudu.client-version-0.6.0-released" />
		<link rel="enclosure" type="image" href="https://cdn.devlead.se/clipimg-vscode/2021/01/11/1f2af322-a19f-753d-bd3e-00118dc674f1.png?sv=2019-12-12&amp;st=2021-01-10T15%253A16%253A48Z&amp;se=2031-01-11T15%253A16%253A48Z&amp;sr=b&amp;sp=r&amp;sig=RYHdZjTvO%252Fw0tUGsgnIiGJRhTiQQPHnEsSKtnV14Yoc%253D" />
		<updated>2018-06-03T00:00:00Z</updated>
		<content>&lt;p&gt;This version fixes a breaking change in the Azure App Services Run-From-Zip web app deployment feature.&lt;/p&gt;
&lt;h2 id="app-service-changes"&gt;App Service Changes&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;App Setting: &lt;code&gt;WEBSITE_USE_ZIP&lt;/code&gt; --&amp;gt; &lt;code&gt;WEBSITE_RUN_FROM_ZIP&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Marker filename: &lt;code&gt;siteversion.txt&lt;/code&gt; --&amp;gt; &lt;code&gt;packagename.txt&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="action-you-need-to-take"&gt;Action you need to take&lt;/h2&gt;
&lt;p&gt;As the App Setting has change you’ll need to change you setting name to &lt;code&gt;WEBSITE_RUN_FROM_ZIP&lt;/code&gt; (it’s value should still be &lt;code&gt;1&lt;/code&gt; )&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/11/b0858633-3124-5aec-09c6-de238e198b19.png?sv=2019-12-12&amp;amp;st=2021-01-10T09%3A54%3A47Z&amp;amp;se=2031-01-11T09%3A54%3A47Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=D%2BroDxmN6v7WRtasetPKfTpV%2Bxj2Y%2Bx3vM0Mc97pbwo%3D" alt="App Service App Settings" /&gt;&lt;/p&gt;
&lt;p&gt;Maker filename is handled by the new version so all you need to update scripts to use Cake.Kudu.Client version &lt;code&gt;0.6.0&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;#addin nuget:?package=Cake.Kudu.Client&amp;amp;version=0.6.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;nothing else needs to be changed in your Cake script.&lt;/p&gt;
&lt;h2 id="verifying-change"&gt;Verifying change&lt;/h2&gt;
&lt;p&gt;You can verify the publish succeeded under App Service Advanced Tools ( Kudu ) — Debug Console by navigating to &lt;code&gt;data/SitePackages&lt;/code&gt; and see deployment package and the new &lt;code&gt;packagename.txt&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/11/73564b06-ae73-e415-a9f3-f34c69bbddd5.png?sv=2019-12-12&amp;amp;st=2021-01-10T09%3A56%3A42Z&amp;amp;se=2031-01-11T09%3A56%3A42Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=471bIcnxlyPDPBXWGvnPeSRQ0YHSoT4FFkcv1qb9pdQ%3D" alt="Kudu Debug Console" /&gt;&lt;/p&gt;
&lt;h2 id="full-example"&gt;Full example&lt;/h2&gt;
&lt;p&gt;If you haven’t used the feature before below is a full example&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;#addin nuget:?package=Cake.Kudu.Client&amp;amp;version=0.6.0

Task(&amp;quot;Deploy-Run-From-Zip&amp;quot;)
 .Does( ()=&amp;gt;
 {
    string  baseUri     = EnvironmentVariable(&amp;quot;KUDU_CLIENT_BASEURI&amp;quot;),
            userName    = EnvironmentVariable(&amp;quot;KUDU_CLIENT_USERNAME&amp;quot;),
            password    = EnvironmentVariable(&amp;quot;KUDU_CLIENT_PASSWORD&amp;quot;);

    IKuduClient kuduClient = KuduClient(
        baseUri,
        userName,
        password);

    DirectoryPath sourceDirectoryPath = &amp;quot;./website/&amp;quot;;

    FilePath deployFilePath = kuduClient.ZipRunFromDirectory(sourceDirectoryPath);

    Information(&amp;quot;Deployed to {0}&amp;quot;, deployFilePath);
 });

 RunTarget(&amp;quot;Deploy-Run-From-Zip&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/11/8ecbff75-0985-f2e0-b354-9c0095b52cdf.png?sv=2019-12-12&amp;amp;st=2021-01-10T09%3A57%3A52Z&amp;amp;se=2031-01-11T09%3A57%3A52Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=ucQsy%2B4S8GqWnr7bK9N%2BR3QarAsM%2FnUDSrJ5QeRAQTI%3D" alt="Deploy Run From Zip Cake console output log" /&gt;&lt;/p&gt;
&lt;p&gt;Related posts&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://medium.com/hackernoon/introducing-cake-kudu-client-abda40d15f38"&gt;Introducing Cake Kudu Client&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://medium.com/hackernoon/run-from-zip-with-cake-kudu-client-5c063cd72b37"&gt;“Run-From-Zip” with Cake Kudu Client&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>&lt;p&gt;This version fixes a breaking change in the Azure App Services Run-From-Zip web app deployment feature.&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://www.devlead.se/posts/2018/2018-03-26-deploying-net-core-to-azure-using-bitrise-and-cake</id>
		<title>Deploying .NET Core to Azure using Bitrise and Cake</title>
		<author>
			<name>devlead</name>
		</author>
		<link href="https://www.devlead.se/posts/2018/2018-03-26-deploying-net-core-to-azure-using-bitrise-and-cake" />
		<link rel="enclosure" type="image" href="https://cdn.devlead.se/clipimg-vscode/2021/01/11/1f2af322-a19f-753d-bd3e-00118dc674f1.png?sv=2019-12-12&amp;st=2021-01-10T15%253A16%253A48Z&amp;se=2031-01-11T15%253A16%253A48Z&amp;sr=b&amp;sp=r&amp;sig=RYHdZjTvO%252Fw0tUGsgnIiGJRhTiQQPHnEsSKtnV14Yoc%253D" />
		<updated>2018-03-23T00:00:00Z</updated>
		<content>&lt;p&gt;Originally published at &lt;a href="https://blog.bitrise.io/deploying-net-core-to-azure-using-bitrise-and-cake/"&gt;blog.bitrise.com&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Mattias Karlsson demonstrates how you can build and ship a .NET Core website using a custom docker build image and the open source build system Cake.&lt;/p&gt;
&lt;p&gt;Guest blog post by Mattias Karlsson.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Mattias Karlsson is a Microsoft Azure MVP and Open Source maintainer.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/11/6ce723c3-edc9-8b41-6ed2-d474367040f5.png?sv=2019-12-12&amp;amp;st=2021-01-10T12%3A03%3A31Z&amp;amp;se=2031-01-11T12%3A03%3A31Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=EMmpaNTM2%2Bhh3%2BVry4Tdumjs6aEMKLZwIKGQVE%2Bhwco%3D" alt="Bitrise Cake" /&gt;&lt;/p&gt;
&lt;p&gt;Bitrise is mostly known for providing hosted continuous integration and deployment targeting iOS and Android projects, but it’s much more capable than that and can build and ship basically anything you can build on MacOS or Linux.&lt;/p&gt;
&lt;h2 id="adding-a-project-to-bitrise"&gt;Adding a project to Bitrise&lt;/h2&gt;
&lt;p&gt;Adding a new project is straightforward, click the “Add new app” Button.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/11/6bffcbe9-e099-e882-c949-7578884ff356.png?sv=2019-12-12&amp;amp;st=2021-01-10T12%3A04%3A12Z&amp;amp;se=2031-01-11T12%3A04%3A12Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=XsOZ8Dbh2%2F5ScmcaC5NIp2nFni6IJ5cl8%2B%2BTYfX8kKQ%3D" alt="Add New Bitrise app" /&gt;&lt;/p&gt;
&lt;p&gt;Then pick your source code management provider of choice and pick your project.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/11/2d53378d-28c4-81c1-7455-65648e9e1156.png?sv=2019-12-12&amp;amp;st=2021-01-10T12%3A04%3A46Z&amp;amp;se=2031-01-11T12%3A04%3A46Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=0BY%2BinxBgzqkiCooJgYL7ca%2FB7cZsqeRN7hsbKXx4YU%3D" alt="Bitrise new project UI" /&gt;&lt;/p&gt;
&lt;p&gt;Let Bitrise setup SSH keys and validate the repository.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/11/77e1853c-dcd6-e0e7-7f9e-fc011611912e.png?sv=2019-12-12&amp;amp;st=2021-01-10T12%3A05%3A20Z&amp;amp;se=2031-01-11T12%3A05%3A20Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=nX6475e%2BP%2FmYnKObAcQBmWs68HnZ2GkYRwsu5Anqv44%3D" alt="Bitrise repo access configuration" /&gt;&lt;/p&gt;
&lt;p&gt;Once Bitrise is done validating the repository, pick manual and then &lt;code&gt;other / manual&lt;/code&gt; and &amp;quot;Android &amp;amp; Docker on Ubuntu&amp;quot;, this will let us pick our own custom docker image later.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/11/ef576575-dd01-9bd5-2323-1cbd02a295e2.png?sv=2019-12-12&amp;amp;st=2021-01-10T12%3A05%3A58Z&amp;amp;se=2031-01-11T12%3A05%3A58Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=vLe20a998sciuAvXRTZOFtgVq6v4rWfjFqzY0S9hrA0%3D" alt="Bitrise Project build configuration" /&gt;&lt;/p&gt;
&lt;p&gt;To get continuous builds let Bitrise setup a webhook for you:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/11/69c69813-8114-8c85-91ed-00df387e6fd4.png?sv=2019-12-12&amp;amp;st=2021-01-10T12%3A06%3A19Z&amp;amp;se=2031-01-11T12%3A06%3A19Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=WrGowtyfgngndjGfQDezBmt8nTNpuEPgNNnZirQ7yJI%3D" alt="Bitrise webhook setup" /&gt;&lt;/p&gt;
&lt;p&gt;Bitrise will then kick off a build, that will just clone the repository and let you know all is set up.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/11/f3d155a7-0577-67db-7e62-c96a47e3e68b.png?sv=2019-12-12&amp;amp;st=2021-01-10T12%3A06%3A42Z&amp;amp;se=2031-01-11T12%3A06%3A42Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=y2MXfmSVQqX9JWqV53gqrGqkW5uINbTyKWA9oxMfO6k%3D" alt="Bitrise running build" /&gt;&lt;/p&gt;
&lt;h2 id="setup-a-custom-build-docker-image"&gt;Setup a custom build docker image&lt;/h2&gt;
&lt;p&gt;You could download and bootstrap Cake as part of a build step, but Bitrise also lets you pick custom docker images from Docker Hub, which could be tailored with your tools pre-installed. I’ve created and published &lt;code&gt;cakebuild/cake:2.1-sdk-bitrise&lt;/code&gt; on Docker Hub, which contains Bitrise CLI, .NET Core SDK 2.1 and Cake script runner.&lt;/p&gt;
&lt;p&gt;To switch to custom Docker image, navigate to “Workflow” and click on “Stack”.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/11/7abbd37e-e5c1-002a-2e74-e48957a39ed0.png?sv=2019-12-12&amp;amp;st=2021-01-10T12%3A07%3A30Z&amp;amp;se=2031-01-11T12%3A07%3A30Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=n9pR68dRGlzeG25Gqiif%2FhxF8S%2Fdnl7pkR6v4PjdPjs%3D" alt="Bitrise workflow UI" /&gt;&lt;/p&gt;
&lt;p&gt;Then change Docker Image to use to your custom image (i.e. &lt;code&gt;cakebuild/cake:2.1-sdk-bitrise&lt;/code&gt;, the only requirement is that Bitrise CLI and its dependencies need to be present).&lt;/p&gt;
&lt;h2 id="configuring-cake"&gt;Configuring Cake&lt;/h2&gt;
&lt;p&gt;When picking the “manual” template you’ll get 4 build steps, which will handle authentication, fetching code, the “hello world” build script and also handle artifacts.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/11/53b6d29d-26d1-9b4b-bcf9-9df2579e0f69.png?sv=2019-12-12&amp;amp;st=2021-01-10T12%3A13%3A30Z&amp;amp;se=2031-01-11T12%3A13%3A30Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=YtIPD%2Be5oIH6t7DC1o1G6U5WCleKFXeR3yfhYS4oaOc%3D" alt="Bitrise configuring Build work flow" /&gt;&lt;/p&gt;
&lt;p&gt;As Cake is pre-loaded on the custom container image, all that’s needed to execute Cake build script is &lt;code&gt;Cake [path to cake script]&lt;/code&gt;, if your build script is in the root and follows the &lt;code&gt;build.cake&lt;/code&gt; convention, then all that's needed is &lt;code&gt;Cake&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/11/60b0c772-1718-2cfa-9d9e-6c7b1ae0124c.png?sv=2019-12-12&amp;amp;st=2021-01-10T12%3A15%3A08Z&amp;amp;se=2031-01-11T12%3A15%3A08Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=N%2FlvKWLEw4KZeNrmwssdn5ZgRNYdzxJOhEn02mswtCA%3D" alt="Bitrise Cake build step" /&gt;&lt;/p&gt;
&lt;h2 id="the-build-script"&gt;The Build script&lt;/h2&gt;
&lt;p&gt;The example &lt;a href="https://github.com/azurevoodoo/DeployingToAzureUsingBitriseAndCake/blob/master/build.cake"&gt;build.cake&lt;/a&gt; used for this post has the following steps&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Clean build output &amp;amp; Restore build dependencies&lt;/li&gt;
&lt;li&gt;Build code&lt;/li&gt;
&lt;li&gt;Run unit tests&lt;/li&gt;
&lt;li&gt;Publish web&lt;/li&gt;
&lt;li&gt;Deploy to Azure&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Deploying to Azure is done using Azure App Service Kudu rest API using the &lt;a href="https://hackernoon.com/introducing-cake-kudu-client-abda40d15f38"&gt;Cake.Kudu.Client&lt;/a&gt; Cake addin.&lt;/p&gt;
&lt;h2 id="keeping-secrets"&gt;Keeping secrets&lt;/h2&gt;
&lt;p&gt;To deploy to Azure with Cake.Kudu.Client, you’ll need the base URL for the site’s Kudu API, the username, and password. You can find this information by downloading your publishing profile from the Azure portal&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/11/9246ea9b-4f1a-6d44-49bc-2259baf27317.png?sv=2019-12-12&amp;amp;st=2021-01-10T12%3A17%3A08Z&amp;amp;se=2031-01-11T12%3A17%3A08Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=awELNBjLpVX389GaIU%2Flod3ecRMC6t4J06j%2B6US9IQ8%3D" alt="Azure Portal App Servuce overview blade" /&gt;&lt;/p&gt;
&lt;p&gt;This is, of course, sensitive information that you don’t want to be in your repository or accessible from e.g. pull requests.&lt;/p&gt;
&lt;p&gt;To cater for this need Bitrise provides “Secrets”, Secrets are exposed as environment variables, so they can easily be consumed from build steps / scripts. But to add an extra level of security they’re not part of your build definition and by default, they won’t be available from pull requests.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/11/7c7e9f35-228b-5473-7d48-4d9ff08483da.png?sv=2019-12-12&amp;amp;st=2021-01-10T12%3A17%3A49Z&amp;amp;se=2031-01-11T12%3A17%3A49Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=zt4xJyLiZCO5AC%2FwWXRxELQREb68NpgVQtSf7aajVxQ%3D" alt="Bitrise Secret Environment Variables" /&gt;&lt;/p&gt;
&lt;h2 id="all-set"&gt;All set&lt;/h2&gt;
&lt;p&gt;Now hit Start a Build or push a commit and your website will continuously build and deploy.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/11/1ce86013-621d-ba8f-3490-37902ab1b0dc.png?sv=2019-12-12&amp;amp;st=2021-01-10T12%3A20%3A20Z&amp;amp;se=2031-01-11T12%3A20%3A20Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=aXM%2BQrIollFehwDDMS7dxEGY9e96s5x26HXe70jqMEs%3D" alt="Bitrise Start/Schedule new build" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/11/aeaed4b6-04dc-d99e-fe2a-bb8ffcc04057.png?sv=2019-12-12&amp;amp;st=2021-01-10T12%3A20%3A33Z&amp;amp;se=2031-01-11T12%3A20%3A33Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=2JZDluWVvMzRVKOyjaX4IqQmWavSwfynDIzBBEARCUQ%3D" alt="Cake build log" /&gt;&lt;/p&gt;
&lt;h2 id="resources"&gt;Resources&lt;/h2&gt;
&lt;p&gt;The example repository can be found on GitHub &lt;a href="https://github.com/azurevoodoo/DeployingToAzureUsingBitriseAndCake"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A GitHub Gist of the Bitrise build definition is available &lt;a href="https://gist.github.com/devlead/6086fe79b0a5e4ebbbf145d4244a9713"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you haven’t but want to try Bitrise, then you can use &lt;a href="https://www.bitrise.io/?referrer=8049ac73f66b5427"&gt;this referral link&lt;/a&gt; which benefits the &lt;a href="https://cakebuild.net/"&gt;Cake&lt;/a&gt; project.&lt;/p&gt;
</content>
		<summary>&lt;p&gt;Originally published at &lt;a href="https://blog.bitrise.io/deploying-net-core-to-azure-using-bitrise-and-cake/"&gt;blog.bitrise.com&lt;/a&gt;.&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://www.devlead.se/posts/2018/2018-02-20-run-from-zip-with-cake-kudu-client</id>
		<title>“Run-From-Zip” with Cake Kudu Client</title>
		<author>
			<name>devlead</name>
		</author>
		<link href="https://www.devlead.se/posts/2018/2018-02-20-run-from-zip-with-cake-kudu-client" />
		<link rel="enclosure" type="image" href="https://cdn.devlead.se/clipimg-vscode/2021/01/11/1f2af322-a19f-753d-bd3e-00118dc674f1.png?sv=2019-12-12&amp;st=2021-01-10T15%253A16%253A48Z&amp;se=2031-01-11T15%253A16%253A48Z&amp;sr=b&amp;sp=r&amp;sig=RYHdZjTvO%252Fw0tUGsgnIiGJRhTiQQPHnEsSKtnV14Yoc%253D" />
		<updated>2018-02-20T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/11/29bf78b1-94f2-6301-ec83-fd4541c438b7.png?sv=2019-12-12&amp;amp;st=2021-01-10T12%3A37%3A03Z&amp;amp;se=2031-01-11T12%3A37%3A03Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=eyImi7f1xhlW0EtOsWQOS5NhsBgUv6fWlKtF03AqOXc%3D" alt="Ship at sea" /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Update! Since this post was written, there’s been some breaking changes to Azure App Services Run-From-Zip feature, this was fixed in Cake.Kudu.Client version 0.6.0 you can read more about that at the post below
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href="https://medium.com/&amp;#64;devlead/cake-kudu-client-version-0-6-0-released-cb6435629684"&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/11/3d72e5ff-aca6-965a-1989-d837ba7cce69.png?sv=2019-12-12&amp;amp;st=2021-01-10T12%3A35%3A54Z&amp;amp;se=2031-01-11T12%3A35%3A54Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=bbuUUuci2RePI%2BEBfDKhyAvBNOV98aYSZ%2FBEqXNQ%2F1M%3D" alt="Cake.Kudu Client version 0.6.0 released" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;A couple of days ago Azure announced that they in preview added a new way to do app services deployments called &lt;a href="https://github.com/Azure/app-service-announcements/issues/84"&gt;Run-From-Zip&lt;/a&gt;, which lets you deploy using a zip file.&lt;/p&gt;
&lt;p&gt;Deploying using a zip file as been possible before, the difference with this new method is that the file isn’t extracted into the “wwwroot” directory, but instead the zip file &lt;em&gt;mounted&lt;/em&gt; read only as “wwwroot”.&lt;/p&gt;
&lt;p&gt;The zip file can either be hosted externally from the site or in a special folder on the app service itself, and the latter is now what the “Kudu Client” Cake addin now supports — enabling you to use this new method of deployment in your Cake build scripts.&lt;/p&gt;
&lt;h2 id="prerequisites"&gt;Prerequisites&lt;/h2&gt;
&lt;p&gt;To enable Run-From-Zip deployments you’ll first need to set an application setting called &lt;code&gt;WEBSITE_USE_ZIP&lt;/code&gt;, you either set this to an url when deploying from an external source, or in this case just set it to &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/11/6ca61d0c-daf2-3ada-e681-a129eee866fe.png?sv=2019-12-12&amp;amp;st=2021-01-10T12%3A38%3A49Z&amp;amp;se=2031-01-11T12%3A38%3A49Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=RHcKAy41C%2FrjCXhM5jfrZsIqlSi%2BEamUIZoLSp%2Bqjao%3D" alt="App Service app settings" /&gt;&lt;/p&gt;
&lt;h2 id="ziprunfromdirectory"&gt;ZipRunFromDirectory&lt;/h2&gt;
&lt;p&gt;Naming things is hard, but the addin now has a method called &lt;a href="https://cakebuild.net/api/Cake.Kudu.Client.Extensions/KuduClientZipExtensions/AA111BEB"&gt;ZipRunFromDirectory&lt;/a&gt;, which will do all the “heavy lifting” and deploy a local directory.&lt;/p&gt;
&lt;h2 id="example-usage"&gt;Example usage&lt;/h2&gt;
&lt;p&gt;o deploying a site using this new method just becomes a couple of lines of code&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;#addin nuget:?package=Cake.Kudu.Client&amp;amp;version=0.3.0

string  baseUri     = EnvironmentVariable(&amp;quot;KUDU_CLIENT_BASEURI&amp;quot;),
        userName    = EnvironmentVariable(&amp;quot;KUDU_CLIENT_USERNAME&amp;quot;),
        password    = EnvironmentVariable(&amp;quot;KUDU_CLIENT_PASSWORD&amp;quot;);

IKuduClient kuduClient = KuduClient(
    baseUri,
    userName,
    password);

DirectoryPath sourceDirectoryPath = &amp;quot;./Documentation/&amp;quot;;

FilePath deployFilePath = kuduClient.ZipRunFromDirectory(sourceDirectoryPath);

Information(&amp;quot;Deployed to {0}&amp;quot;, deployFilePath);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The file path returned, is the zip file deployed to the app service.&lt;/p&gt;
&lt;h2 id="behind-the-curtain"&gt;Behind the curtain&lt;/h2&gt;
&lt;p&gt;So what does actually happen here?
In a nutshell the method will:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;In memory zip source directory&lt;/li&gt;
&lt;li&gt;Push that zip to d:\home\data\SitePackages to a unique date stamped file name&lt;/li&gt;
&lt;li&gt;Push the filename of the zip to d:\home\data\SitePackages\siteversion.txt&lt;/li&gt;
&lt;li&gt;Via Kudu API call the site to ensure it’s up and right version deployed (a file called KuduClientZipRunFromDirectoryVersion.txt is included in deployed zip for this purpose)&lt;/li&gt;
&lt;li&gt;Return the remote path of the deployed zip&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/11/996eea2c-912e-28db-5430-4a962037b645.png?sv=2019-12-12&amp;amp;st=2021-01-10T12%3A41%3A15Z&amp;amp;se=2031-01-11T12%3A41%3A15Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=jQ0EAY8Joiny7%2BSJEP%2BwyjbR3kZRDBAsWBt%2FSVr5pzU%3D" alt="Kudu deploy zip files" /&gt;&lt;/p&gt;
&lt;h2 id="closing-thoughts"&gt;Closing thoughts&lt;/h2&gt;
&lt;p&gt;I’ve tried this for a couple of days now, and have found deployments to be very stable and quick. But really need some more testing to see what the implications of running this in production, how existing apps behave in a read only mode, etc.&lt;/p&gt;
&lt;p&gt;This is a shiny new feature still in preview, general guidance and tooling support isn’t quite there yet, but as you seen with this post the primitives are in place to build upon and refine the experience in the future!&lt;/p&gt;
&lt;p&gt;&lt;a href="https://hackernoon.com/introducing-cake-kudu-client-abda40d15f38"&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/11/d815ce8f-f979-6770-5abb-02d65e195cf3.png?sv=2019-12-12&amp;amp;st=2021-01-10T12%3A42%3A16Z&amp;amp;se=2031-01-11T12%3A42%3A16Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=r4hBCgyhHLD%2FsHuT3RN49DXX4AeZczADKWtDnKCU5Vc%3D" alt="Introducing Cake Kudu Client" /&gt;&lt;/a&gt;&lt;/p&gt;
</content>
		<summary>A new way to deploy your Azure Web Apps and Function Apps</summary>
	</entry>
	<entry>
		<id>https://www.devlead.se/posts/2018/2018-02-08-introducing-cake-kudu-client</id>
		<title>Introducing Cake Kudu Client</title>
		<author>
			<name>devlead</name>
		</author>
		<link href="https://www.devlead.se/posts/2018/2018-02-08-introducing-cake-kudu-client" />
		<link rel="enclosure" type="image" href="https://cdn.devlead.se/clipimg-vscode/2021/01/11/1f2af322-a19f-753d-bd3e-00118dc674f1.png?sv=2019-12-12&amp;st=2021-01-10T15%253A16%253A48Z&amp;se=2031-01-11T15%253A16%253A48Z&amp;sr=b&amp;sp=r&amp;sig=RYHdZjTvO%252Fw0tUGsgnIiGJRhTiQQPHnEsSKtnV14Yoc%253D" />
		<updated>2018-02-08T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/11/4e020ade-f4b0-0bc4-55d8-fccd0fc0e416.png?sv=2019-12-12&amp;amp;st=2021-01-10T12%3A45%3A04Z&amp;amp;se=2031-01-11T12%3A45%3A04Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=uakWSiJ6qtkF8nHV89itEeTnzN48MTOAzVLHZmfE77g%3D" alt="Long ship at sea" /&gt;&lt;/p&gt;
&lt;p&gt;I’ve previously written how you on Azure App Services itself can build and deploy your web applications and functions utilizing &lt;a href="https://cakebuild.net/"&gt;Cake&lt;/a&gt; build scripts and the &lt;a href="https://www.nuget.org/packages/Cake.Kudu"&gt;Cake.Kudu&lt;/a&gt; addin.&lt;/p&gt;
&lt;p&gt;While it’s fairly easy to get going, just add a build script and connect it to your source code repository of choice, for some scenarios it makes more sense to ship your application prebuilt.&lt;/p&gt;
&lt;p&gt;A few of those scenarios can be&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Static web sites&lt;/strong&gt;, where it requires more resources build, than to serve.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Multi region apps&lt;/strong&gt;, where you deploy same bits to multiple sites and makes sense to just build it once.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Build requirements&lt;/strong&gt;, by building on App services you’re limited to the tooling it has pre-installed or it’s environment supports.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Private resources&lt;/strong&gt;, using private nugget feeds or other compile time sensitive information can be cumbersome, and might not be what you want to have lying around on your web site.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="cake-kudu-client-to-the-rescue"&gt;Cake Kudu Client to the rescue&lt;/h2&gt;
&lt;p&gt;Kudu the “engine” behind Azure web and function apps provides and http-based API, which deploy is one of the features it offers. And it’s this API the “Cake Kudu Client” provides a typed C# API which makes it close to a one-liner to deploy from a directory or zip file.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt; #addin nuget:?package=Cake.Kudu.Client

 string  baseUri     = EnvironmentVariable(&amp;quot;KUDU_CLIENT_BASEURI&amp;quot;),
         userName    = EnvironmentVariable(&amp;quot;KUDU_CLIENT_USERNAME&amp;quot;),
         password    = EnvironmentVariable(&amp;quot;KUDU_CLIENT_PASSWORD&amp;quot;);

 IKuduClient kuduClient = KuduClient(
     baseUri,
     userName,
     password);

 DirectoryPath sourceDirectoryPath = &amp;quot;./Documentation/&amp;quot;;

 kuduClient.ZipDeployDirectory(
     sourceDirectoryPath);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What the above does is essentially&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;From environment variables gets Kudu endpoint for your App Service (i.e. &lt;code&gt;https://{yoursite}.scm.azurewebsites.net&lt;/code&gt;), user name and password.&lt;/li&gt;
&lt;li&gt;Instantiate a new client using the &lt;code&gt;KuduClient&lt;/code&gt; alias.&lt;/li&gt;
&lt;li&gt;Use the &lt;code&gt;ZipDeployDirectory&lt;/code&gt; method which with zip that folder in memory and deploy it.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;A real world example using this with the static site generator WYAM could look something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;#tool &amp;quot;nuget:https://api.nuget.org/v3/index.json?package=Wyam&amp;amp;version=1.2.0&amp;quot;
#addin &amp;quot;nuget:https://api.nuget.org/v3/index.json?package=Cake.Wyam&amp;amp;version=1.2.0&amp;quot;
#addin &amp;quot;nuget:https://api.nuget.org/v3/index.json?package=Cake.Kudu.Client&amp;amp;version=0.1.0&amp;quot;

DirectoryPath   outputPath = MakeAbsolute(Directory(&amp;quot;./output&amp;quot;));
string          target     = Argument(&amp;quot;target&amp;quot;, &amp;quot;Kudu-Publish-Documentation&amp;quot;),
                baseUri    = EnvironmentVariable(&amp;quot;KUDU_CLIENT_BASEURI&amp;quot;),
                userName   = EnvironmentVariable(&amp;quot;KUDU_CLIENT_USERNAME&amp;quot;),
                password   = EnvironmentVariable(&amp;quot;KUDU_CLIENT_PASSWORD&amp;quot;);

Task(&amp;quot;Clean-Documentation&amp;quot;)
    .Does(() =&amp;gt;
{
    CleanDirectory(outputPath);
});

Task(&amp;quot;Generate-Documentaton&amp;quot;)
    .IsDependentOn(&amp;quot;Clean-Documentation&amp;quot;)
    .Does(() =&amp;gt;
{
    Wyam(new WyamSettings
    {
        Recipe = &amp;quot;Docs&amp;quot;,
        Theme = &amp;quot;Samson&amp;quot;,
        OutputPath = outputPath,
        Settings = new Dictionary&amp;lt;string, object&amp;gt;
        {
            { &amp;quot;BaseEditUrl&amp;quot;, &amp;quot;https://github.com/cake-contrib/Cake.Kudu.Client&amp;quot; },
            { &amp;quot;SourceFiles&amp;quot;, &amp;quot;./src&amp;quot; },
            { &amp;quot;Title&amp;quot;, &amp;quot;Cake Kudu Client&amp;quot; }
    }});
});

Task(&amp;quot;Kudu-Publish-Documentation&amp;quot;)
    .IsDependentOn(&amp;quot;Generate-Documentaton&amp;quot;)
    .WithCriteria(!string.IsNullOrEmpty(baseUri)
        &amp;amp;&amp;amp; !string.IsNullOrEmpty(userName)
        &amp;amp;&amp;amp; !string.IsNullOrEmpty(password)
    )
    .Does(()=&amp;gt;
{
    IKuduClient kuduClient = KuduClient(
        baseUri,
        userName,
        password);

    kuduClient.ZipDeployDirectory(
        outputPath);
});

RunTarget(target);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="not-just-deployments"&gt;Not just deployments&lt;/h2&gt;
&lt;p&gt;Deployments is only one of the features the Cake Kudu Client addin handles&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Execute remote shell commands&lt;/li&gt;
&lt;li&gt;Enumerate remote files and directories on&lt;/li&gt;
&lt;li&gt;Upload files and directories to AppService&lt;/li&gt;
&lt;li&gt;Download files and directories from AppService&lt;/li&gt;
&lt;li&gt;Deploy to AppService from local folder or zip file&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;and more features are planned.&lt;/p&gt;
&lt;p&gt;You can find the complete list of available methods with examples are available on the Cake web site at:
&lt;a href="https://cakebuild.net/dsl/kudu/"&gt;cakebuild.net/dsl/kudu/&lt;/a&gt;&lt;/p&gt;
</content>
		<summary>Ship remotely to Azure App Services using Cake</summary>
	</entry>
	<entry>
		<id>https://www.devlead.se/posts/2017/2017-08-27-polyfill-with-powershell</id>
		<title>Polyfill with PowerShell</title>
		<author>
			<name>devlead</name>
		</author>
		<link href="https://www.devlead.se/posts/2017/2017-08-27-polyfill-with-powershell" />
		<link rel="enclosure" type="image" href="https://cdn.devlead.se/clipimg-vscode/2021/01/11/1f2af322-a19f-753d-bd3e-00118dc674f1.png?sv=2019-12-12&amp;st=2021-01-10T15%253A16%253A48Z&amp;se=2031-01-11T15%253A16%253A48Z&amp;sr=b&amp;sp=r&amp;sig=RYHdZjTvO%252Fw0tUGsgnIiGJRhTiQQPHnEsSKtnV14Yoc%253D" />
		<updated>2017-08-20T00:00:00Z</updated>
		<content>&lt;p&gt;When writing scripts, targeting multiple runtime versions can be really painful, scripts can be forked in different files or contain hairy conditional statements to handle differences/missing between versions of PowerShell runtime/modules, resulting in unreadable and unmaintainable spaghetti code.&lt;/p&gt;
&lt;p&gt;What if you instead detect missing commands and supply an implementation for those when needed? This would allow you to have your scripts look the same and basically be agnostic to the which runtime it’s running on, making code more concise and easier to maintain.&lt;/p&gt;
&lt;p&gt;The technique for this is called polyfilling and is common practise in web development where things can differ between browser versions and vendors.&lt;/p&gt;
&lt;p&gt;It turns out it’s fairly simple to do in PowerShell, I’ll demonstrate this using the &lt;a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.archive/expand-archive?view=powershell-5.0"&gt;Expand-Archive&lt;/a&gt; command that was introduced in PowerShell 5, which extracts files from a specified archive&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;Expand-Archive
      -DestinationPath] &amp;lt;String&amp;gt;
      -LiteralPath &amp;lt;String&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It’ll obviously fail miserably on previous versions of PowerShell&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/11/6b6ac33f-a389-ab22-e0e7-533d069770ce.png?sv=2019-12-12&amp;amp;st=2021-01-10T12%3A57%3A25Z&amp;amp;se=2031-01-11T12%3A57%3A25Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=mbq3sabMzSdHFGGntTGEUJ3Ya%2BaalzKv3zX2U2svLXA%3D" alt="Expand-Archive failes on previous versions of PowerShell" /&gt;&lt;/p&gt;
&lt;p&gt;As PowerShell has the full power of .NET we can utilize the ZipFile class that has been provided since .NET 4.5 (&lt;em&gt;for even older versions of PowerShell we could also potentially just shell out to 7zip or similar command line utility or utilize 3rd party .NET assembly, as we can do anything in our polyfill that’s possible PowerShell&lt;/em&gt;).
Such a polyfill could look something like below:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;if (-not (Get-Command Expand-Archive -ErrorAction SilentlyContinue))
{
  &amp;amp; {
    Add-Type -AssemblyName System.IO.Compression.FileSystem
    function global:Expand-Archive
    {
        param([string]$Path, [string]$DestinationPath)
        [System.IO.Compression.ZipFile]::ExtractToDirectory($Path, $DestinationPath)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above script checks if command exists, if it doesn’t it’ll execute a code block which will create a globally available function, with the parameters and functionality we expect. To use it in our scripts we dot source it into our script or shell
&lt;code&gt;. .\Expand-Archive.Polyfill.ps1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/11/32e374ff-3b83-e9eb-a0a7-39cac1d37cca.png?sv=2019-12-12&amp;amp;st=2021-01-10T12%3A59%3A00Z&amp;amp;se=2031-01-11T12%3A59%3A00Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=ZPFzNZQHdnUgbLCeJAf9pfwFGg1N7VdOWHzO9A%2F0Xqs%3D" alt="Demonstraing Expand-Archive available" /&gt;&lt;/p&gt;
&lt;p&gt;and it’ll be available for us to utilize just like we would have done in a newer version of PowerShell.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cdn.devlead.se/clipimg-vscode/2021/01/11/02fd4235-bed7-d9ea-299b-4cbb38ec58b8.png?sv=2019-12-12&amp;amp;st=2021-01-10T12%3A59%3A43Z&amp;amp;se=2031-01-11T12%3A59%3A43Z&amp;amp;sr=b&amp;amp;sp=r&amp;amp;sig=DMrIzL%2FATJBZdm7cb6kkCKU7DZrKbTGJzTAycjgKO0k%3D" alt="Demonstrating usage of the polyfilled command" /&gt;&lt;/p&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Polyfilling is a very neat way having more homogenous and maintainable scripts, while also letting you adopt new commands and features, even if you have one or two old servers in the closet ;)&lt;/p&gt;
</content>
		<summary>Spackle missing pieces on legacy versions of PowerShell</summary>
	</entry>
</feed>